<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.04.07"/>
        <title>xtfa.outputPipelines - xTFA 2022-07 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=68f4518137b9aefe99b631505a2064c3c42c9852" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">xTFA 2022-07 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">xTFA 2022-07 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../relationmanuscript.html">Relations Between the Notions of the Manuscript and their Implementation in the Tool</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../modules.html">xtfa</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../xtfa.html">xtfa package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.GurobiInterface.html">xtfa.GurobiInterface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.MilpInterface.html">xtfa.MilpInterface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.baharevMfas.html">xtfa.baharevMfas module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.clocks.html">xtfa.clocks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.contentionPipelines.html">xtfa.contentionPipelines module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.fasUtility.html">xtfa.fasUtility module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.flows.html">xtfa.flows module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.graphUtility.html">xtfa.graphUtility module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.inputPipelines.html">xtfa.inputPipelines module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.lcan.html">xtfa.lcan module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.minPlusToolbox.html">xtfa.minPlusToolbox module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.networks.html">xtfa.networks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.nodes.html">xtfa.nodes module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.outputPipelines.html">xtfa.outputPipelines module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.plotUtility.html">xtfa.plotUtility module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.unitUtility.html">xtfa.unitUtility module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container"><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for xtfa.outputPipelines</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3</span>
<span class="c1">#</span>
<span class="c1"># This file is part of xTFA</span>
<span class="c1"># Copyright (c) 2021-2022 Ludovic Thomas (ISAE-SUPAERO)</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify  </span>
<span class="c1"># it under the terms of the GNU General Public License as published by  </span>
<span class="c1"># the Free Software Foundation, version 3.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but </span>
<span class="c1"># WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<span class="c1"># General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License </span>
<span class="c1"># along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">"""</span>
<span class="sd">This module contains the definition of the flow-state computation pipeline</span>
<span class="sd">In the software, the flow-state computation pipeline computational pipeline is called the "output pipeline" (legacy name)</span>
<span class="sd">The role of this pipeline is, once the delay bound in this node has been computed, to update all the individual flow states with the individual arrival curves.</span>

<span class="sd">The file is split in two parts:</span>
<span class="sd">-First all the possible computational blocks inside the pipeline are defined</span>
<span class="sd">-Then the low-state computation pipeline itself is defined.</span>
<span class="sd">"""</span>



<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">unitUtility</span>
<span class="kn">from</span> <span class="nn">xtfa.clocks</span> <span class="kn">import</span> <span class="n">Clock</span>
<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">flows</span>
<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">minPlusToolbox</span> <span class="k">as</span> <span class="n">mpt</span>
<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">unitUtility</span>
<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">inputPipelines</span>




<div class="viewcode-block" id="OutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">OutputPipelineStep</span><span class="p">:</span>
    <span class="sd">"""This is the interface for a computational block in the output pipeline.</span>
<span class="sd">    The structure of the class is similar to an ACP computational block we refer to the ACP (ie input pipeline) for details.</span>
<span class="sd">    """</span>
    <span class="n">_nodeName</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span> <span class="o">=</span> <span class="n">nodeName</span>

<div class="viewcode-block" id="OutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="OutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="OutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div></div>

<div class="viewcode-block" id="FromKeyTaggingOutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromKeyTaggingOutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">FromKeyTaggingOutputPipelineStep</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This computational block does not exactly compute anything.</span>
<span class="sd">    It adds the current node to the list of ancestors in all outgoing flow states.</span>
<span class="sd">    This correspond to adding the current node to the set \mathcal{U} defined in the manuscript.</span>
<span class="sd">    As a consequence, all the flow states wil 'automatically' remember the delay they have suffered since the current node.</span>
<span class="sd">    """</span>

    <span class="n">_selectiveTag</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_tagList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">Flow</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selectiveTag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tagList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        
    
<div class="viewcode-block" id="FromKeyTaggingOutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromKeyTaggingOutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" To install this block, the tag "tag-reference-point" should be in compuFlags.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"tag-reference-point"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="FromKeyTaggingOutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromKeyTaggingOutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">""" If the tag "tag-reference-point" in compuFlags equal "all", all flow states will be tagged, otherwise it should contain a comma-separated list of flow names to tag.</span>
<span class="sd">        """</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">FromKeyTaggingOutputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"tag-reference-point"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"all"</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">instance</span>
        <span class="c1"># selective mode enabled</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_selectiveTag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">flowTagStr</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"tag-reference-point"</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">","</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_tagList</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flows</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">flowTagStr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">instance</span></div>

<div class="viewcode-block" id="FromKeyTaggingOutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromKeyTaggingOutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectiveTag</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tagList</span><span class="p">)):</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">addDelayFromEntry</span><span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="s2">"node_name"</span><span class="p">])</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">addRtoFromEntry</span><span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="s2">"node_name"</span><span class="p">])</span></div></div>

<div class="viewcode-block" id="DeltaDDeconvolutionOutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.DeltaDDeconvolutionOutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">DeltaDDeconvolutionOutputPipelineStep</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This computationnal step takes the input flow state and worsens it by the delay bound in this node.</span>
<span class="sd">    """</span>

<div class="viewcode-block" id="DeltaDDeconvolutionOutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.DeltaDDeconvolutionOutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"PROP"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DeltaDDeconvolutionOutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.DeltaDDeconvolutionOutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">net</span> <span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">DeltaDDeconvolutionOutputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">step</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>

<div class="viewcode-block" id="DeltaDDeconvolutionOutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.DeltaDDeconvolutionOutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">deconvolutionService</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">maxContentionDelay</span> <span class="o">-</span> <span class="n">minContentionDelay</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">flow</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="n">maxContentionDelay</span><span class="p">,</span><span class="n">minDelay</span><span class="o">=</span><span class="n">minContentionDelay</span><span class="p">)</span>
            <span class="n">flow</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">/</span> <span class="n">deconvolutionService</span></div></div>

<div class="viewcode-block" id="FromSourceDeltaDDeconvolutionOutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromSourceDeltaDDeconvolutionOutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">FromSourceDeltaDDeconvolutionOutputPipelineStep</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This computationnal step differs from the previous one as it performs the deconvolution not of the input flow state but of the source arrival curve (or the arrival curve of the last regulator)</span>
<span class="sd">    """</span>

<div class="viewcode-block" id="FromSourceDeltaDDeconvolutionOutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromSourceDeltaDDeconvolutionOutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"PROP"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="FromSourceDeltaDDeconvolutionOutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromSourceDeltaDDeconvolutionOutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FromSourceDeltaDDeconvolutionOutputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>

<div class="viewcode-block" id="FromSourceDeltaDDeconvolutionOutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.FromSourceDeltaDDeconvolutionOutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="n">maxContentionDelay</span><span class="p">,</span><span class="n">minDelay</span><span class="o">=</span><span class="n">minContentionDelay</span><span class="p">)</span>
            <span class="n">lastFresh</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"last-fresh"</span><span class="p">,</span> <span class="s2">"source"</span><span class="p">)</span>
            <span class="n">lastFreshAc</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="n">lastFresh</span><span class="p">)</span>
            <span class="c1">#in TAI</span>
            <span class="n">lastFreshAc</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">.</span><span class="n">worsen_arrival_curve</span><span class="p">(</span><span class="n">lastFreshAc</span><span class="p">)</span>
            <span class="n">minD</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">lastFresh</span><span class="p">]</span>
            <span class="n">maxD</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">lastFresh</span><span class="p">]</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">lastFreshAc</span> <span class="o">/</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">maxD</span> <span class="o">-</span> <span class="n">minD</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="CeilBurstsOutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.CeilBurstsOutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">CeilBurstsOutputPipelineStep</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">""" This block is only used with the fix-point version of xTFA, it ceils the burst and the lmax delay so that fix point can be reached with strict equality</span>
<span class="sd">    """</span>

    <span class="n">decimalsDelay</span><span class="p">:</span> <span class="nb">int</span>

<div class="viewcode-block" id="CeilBurstsOutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.CeilBurstsOutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"CEIL"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"ceil-bursts"</span><span class="p">,</span> <span class="s2">"False"</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"True"</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CeilBurstsOutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.CeilBurstsOutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">CeilBurstsOutputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimalsDelay</span> <span class="o">=</span> <span class="mi">15</span>

<div class="viewcode-block" id="CeilBurstsOutputPipelineStep.round_decimals_up"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.CeilBurstsOutputPipelineStep.round_decimals_up">[docs]</a>    <span class="k">def</span> <span class="nf">round_decimals_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a value rounded up to a specific number of decimal places.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"decimal places must be an integer"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">decimals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"decimal places has to be 0 or more"</span><span class="p">)</span>  
        <span class="k">elif</span> <span class="n">decimals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">decimals</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">decimals</span><span class="p">)</span> <span class="o">==</span> <span class="n">number</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">number</span>

        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">number</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span></div>

<div class="viewcode-block" id="CeilBurstsOutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.CeilBurstsOutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">ceil_bursts</span><span class="p">()</span>
            
            <span class="c1">#only rounding up the max from source, the min and rto are not rounded cause not used as convergence variables</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="s2">"source"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round_decimals_up</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="s2">"source"</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimalsDelay</span><span class="p">)</span></div></div>
    

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateMergingOutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.PacketEliminationFunctionFlowStateMergingOutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">PacketEliminationFunctionFlowStateMergingOutputPipelineStep</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This block merges the flow states of a flow that has been processed by a PEF, if it was not already done in the input pipeline.</span>
<span class="sd">    Basically when two flow states belonging to the same flow cross the node and their duplicates are eliminated by a PEF, this block merges them into a single flow state.</span>
<span class="sd">    """</span>
    <span class="n">_selectiveMerge</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_flowsToMerge</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">Flow</span><span class="p">]</span>

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateMergingOutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.PacketEliminationFunctionFlowStateMergingOutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">inputPipelines</span><span class="o">.</span><span class="n">PacketEliminationFunctionFlowStateForceMergingInputPipelineStep</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)):</span>
            <span class="c1">#do not install if already present in input</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="s2">"PE"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">"SPE"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">)))):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"packet-elimination-function"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateMergingOutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.PacketEliminationFunctionFlowStateMergingOutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">PacketEliminationFunctionFlowStateMergingOutputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"packet-elimination-function"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"all"</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">instance</span>
        <span class="c1"># selective mode enabled</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_selectiveMerge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">flowMergeStr</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"packet-elimination-function"</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">","</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_flowsToMerge</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flows</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">flowMergeStr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">instance</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aNodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">aNodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selectiveMerge</span> <span class="o">=</span> <span class="kc">False</span>       

    
    <span class="k">def</span> <span class="nf">_countFlowInFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="n">flows</span><span class="o">.</span><span class="n">Flow</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">]):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flow</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">_getSetOfFlowsToMerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">Flow</span><span class="p">]:</span>
        <span class="n">flowsToMerge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Count the number of flows for which we observe more than one flow state -&gt; means the flow has been duplicated</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_countFlowInFlowStates</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">flowsToMerge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="c1"># Intersect with the limiting list of flows to merge for this specific step</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selectiveMerge</span><span class="p">):</span>
            <span class="n">flowsToMerge</span> <span class="o">=</span> <span class="n">flowsToMerge</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flowsToMerge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flowsToMerge</span>

    <span class="k">def</span> <span class="nf">_getClosestKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graphOfFlow</span><span class="p">:</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">sourceKeys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="s1">'source'</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sourceKeys</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="s2">":"</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="c1"># do not process ATS stuff here</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">):</span>
                <span class="c1"># This key cannot strictly be closer than the current canditate</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">):</span>
                <span class="c1"># The candidate cannot strictly be closer than the current key</span>
                <span class="c1"># so we can flip</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">continue</span>
            <span class="c1"># Here, neither 'key' nor 'candidate' can be equal to 'source' so they are valid node names in the flow graph</span>
            <span class="n">distance_candidate</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graphOfFlow</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">candidate</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
            <span class="n">distance_key</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graphOfFlow</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">distance_key</span> <span class="o">&lt;</span> <span class="n">distance_candidate</span><span class="p">):</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">candidate</span>

    <span class="k">def</span> <span class="nf">_filterFlowStatesForAFlow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">flow</span><span class="p">:</span> <span class="n">flows</span><span class="o">.</span><span class="n">Flow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">]:</span>
        <span class="n">flowStatesForThisFlow</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1">#get the list of flowStates</span>
        <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">.</span><span class="n">flow</span> <span class="o">==</span> <span class="n">flow</span><span class="p">):</span>
                <span class="n">flowStatesForThisFlow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flowStatesForThisFlow</span>
            
    <span class="k">def</span> <span class="nf">_addSufferedRtoForNodesBeforeTheSplit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowState</span><span class="p">:</span> <span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">,</span> <span class="n">rto</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">closestAncestor</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span><span class="p">((</span><span class="n">closestAncestor</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">'source'</span> <span class="ow">in</span> <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="c1">#Closest ancestor is source, only the source key needs to increase its rto</span>
            <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">closestAncestor</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rto</span>
            <span class="k">return</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">":"</span> <span class="ow">in</span> <span class="n">closestAncestor</span><span class="p">):</span>
            <span class="n">closestAncestor</span> <span class="o">=</span> <span class="n">closestAncestor</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1">#here I'm assuming that the tagging is complete:</span>
            <span class="c1">#meaning if a flowstate is tagged at some point in the network, than all the flowstates for the same flow are ALSO tagged</span>
            <span class="c1">#this ensures that, among the rtoFrom.keys(), we have keys that are either common to all paths and preceding the closestAncestor OR at least not present in one of the paths</span>
            <span class="c1">#hence the logic is: add the RTO to keys before the closestAncestor, but do not add it to keys that are after hte closest ancestor because we assume that at least one path is not going through this</span>
            <span class="c1">#key, so basically the packets are not "reordered" from this key because of this merge</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">:</span>
                <span class="c1">#key is source, it is necessarely BEFORE the closestAncestor, increase its key</span>
                <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rto</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="s2">":"</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">subkey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">networkx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">flowState</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">closestAncestor</span><span class="p">):</span>
                <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rto</span>
            

    <span class="k">def</span> <span class="nf">_mergeDelayDictionnaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="n">minDelayDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">maxDelayDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">possibleKeysMin</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">possibleKeysMax</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">:</span>
            <span class="n">possibleKeysMin</span> <span class="o">=</span> <span class="n">possibleKeysMin</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">possibleKeysMax</span> <span class="o">=</span> <span class="n">possibleKeysMax</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#Then for any key, get either the max or the min of the values in the FlowStates that have this key:</span>
        <span class="k">for</span> <span class="n">keyMin</span> <span class="ow">in</span> <span class="n">possibleKeysMin</span><span class="p">:</span>
            <span class="n">minDelayDict</span><span class="p">[</span><span class="n">keyMin</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">keyMin</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">keyMin</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
        <span class="k">for</span> <span class="n">keyMax</span> <span class="ow">in</span> <span class="n">possibleKeysMax</span><span class="p">:</span>
            <span class="n">maxDelayDict</span><span class="p">[</span><span class="n">keyMax</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">keyMax</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">keyMax</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">minDelayDict</span><span class="p">,</span> <span class="n">maxDelayDict</span>
    
<div class="viewcode-block" id="PacketEliminationFunctionFlowStateMergingOutputPipelineStep.mergeRtoDict"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.PacketEliminationFunctionFlowStateMergingOutputPipelineStep.mergeRtoDict">[docs]</a>    <span class="k">def</span> <span class="nf">mergeRtoDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">]:</span>
        <span class="n">rtoDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">possibleKeys</span><span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">:</span>
            <span class="n">possibleKeys</span> <span class="o">=</span> <span class="n">possibleKeys</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#Then for any key, get the max of the rto</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">possibleKeys</span><span class="p">:</span>
            <span class="n">rtoDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
        <span class="k">return</span> <span class="n">rtoDict</span></div>
    

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateMergingOutputPipelineStep.mergeFlags"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.PacketEliminationFunctionFlowStateMergingOutputPipelineStep.mergeFlags">[docs]</a>    <span class="k">def</span> <span class="nf">mergeFlags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">inAll</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">inAll</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span><span class="p">(</span><span class="n">inAll</span><span class="p">):</span>            
                <span class="n">md</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mergingFlowStates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">md</span></div>

    <span class="k">def</span> <span class="nf">_getJitterFromKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">minFromKey</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
        <span class="n">maxFromKey</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">maxFromKey</span> <span class="o">-</span> <span class="n">minFromKey</span><span class="p">)</span>


<div class="viewcode-block" id="PacketEliminationFunctionFlowStateMergingOutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.PacketEliminationFunctionFlowStateMergingOutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getSetOfFlowsToMerge</span><span class="p">(</span><span class="n">flowStates</span><span class="p">):</span>
            <span class="n">flowStatesForThisFlow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filterFlowStatesForAFlow</span><span class="p">(</span><span class="n">flowStates</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
            <span class="c1">#compute the common keys</span>
            <span class="n">fromKeys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">refClock</span> <span class="o">=</span> <span class="n">flowStatesForThisFlow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clock</span>
            <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">ffs</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">refClock</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"The flow states for flow </span><span class="si">%s</span><span class="s2"> at node </span><span class="si">%s</span><span class="s2"> are not observed with the same clock. This is unexpected"</span> <span class="o">%</span> <span class="p">(</span><span class="n">flow</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">))</span>
                <span class="n">fromKeys</span> <span class="o">=</span> <span class="n">fromKeys</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ffs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="c1">#This will be the future merged flow state. We set the correct flow</span>
            <span class="n">newFlowState</span> <span class="o">=</span> <span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>

            <span class="c1"># clock: current node</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">refClock</span>

            <span class="c1">#We take the interection of flags. Duplicates are resolved arbitrarely</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeFlags</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># We need to do a few things: first, we need to merge the dictionnaries of min [resp max] delays into a unique min [resp max] delay dictionnary</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">,</span> <span class="n">newFlowState</span><span class="o">.</span><span class="n">maxDelayFrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mergeDelayDictionnaries</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># Now we also merge the RTO dictionnaries before adding the RTO due to the merging</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">rtoFrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeRtoDict</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># Now we need to add the RTO due to the merge</span>
            <span class="c1"># To do so, we need a bound on non-FIFO jitter between the split and the merge.</span>
            <span class="c1"># The smallest bound that we can obtain is the jitter between the closest ancestor and this current node.</span>
            <span class="c1"># So first let's obtain the closest ancestor</span>
            <span class="n">closestAncestor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getClosestKey</span><span class="p">(</span><span class="n">flow</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">fromKeys</span><span class="p">))</span>
            <span class="c1"># And compute the jitter across all the flow states from this closest ancestor</span>
            <span class="n">nonFifoJitterBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getJitterFromKey</span><span class="p">(</span><span class="n">closestAncestor</span><span class="p">,</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># And now we will add the nonFifoJitter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addSufferedRtoForNodesBeforeTheSplit</span><span class="p">(</span><span class="n">newFlowState</span><span class="p">,</span> <span class="n">nonFifoJitterBound</span><span class="p">,</span> <span class="n">closestAncestor</span><span class="p">)</span>

            <span class="c1"># NOW, WE need to select a leaky-bucket arrival curve valid JUST BEFORE the FIFO contention step</span>
            <span class="c1"># This arrival curve will ONLY be needed if the output arrival curve computation uses propagation instead of re-computing from the source</span>
            <span class="c1"># For this, we select the key for which the deconvolutated leaky-bucket has the SMALLEST BURST</span>
            <span class="n">theNewCurve</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fromKeys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">arrivalCurveAtDivergencePoint</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="c1">#curve not known here, do not use it</span>
                    <span class="k">continue</span>
                <span class="n">dmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
                <span class="n">dmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
                <span class="n">candidateCurve</span> <span class="o">=</span> <span class="n">arrivalCurveAtDivergencePoint</span> <span class="o">/</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theNewCurve</span><span class="p">,</span> <span class="n">mpt</span><span class="o">.</span><span class="n">LeakyBucket</span><span class="p">)):</span>
                    <span class="c1">#the new curve was not assigned yet, assign it</span>
                    <span class="n">theNewCurve</span> <span class="o">=</span> <span class="n">candidateCurve</span>
                    <span class="k">continue</span>
                <span class="k">if</span><span class="p">(</span><span class="n">candidateCurve</span><span class="o">.</span><span class="n">to_leaky_bucket_with_minimum_burst</span><span class="p">()</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">theNewCurve</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()):</span>
                    <span class="n">theNewCurve</span> <span class="o">=</span> <span class="n">candidateCurve</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">theNewCurve</span>
            <span class="c1"># .edge field has not been set, but it will be by the output arrival curve computation step</span>
            <span class="c1">#and of course we remove all the constituing flow states from the list</span>
            <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                <span class="n">flowStates</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="c1">#then we can add this new flow state to the list of flow states</span>
            <span class="n">flowStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newFlowState</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay">[docs]</a><span class="k">class</span> <span class="nc">TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This output pipeline step adds a minimumDelay of Lmin / c where Lmin is the minimum size of any packet in the flow.</span>

<span class="sd">    IT DOES NOT CHANGE THE MAXIMUM DELAYS</span>
<span class="sd">    IT DOES NOT CHANGE THE ARRIVAL CURVE</span>
<span class="sd">    """</span>

    <span class="n">_linkSpeed</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"TDMI"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">"transmission-capacity"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_linkSpeed</span> <span class="o">=</span> <span class="n">unitUtility</span><span class="o">.</span><span class="n">readRate</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"transmission-capacity"</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">instance</span></div>
    
<div class="viewcode-block" id="TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">minPacketLength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linkSpeed</span>
            <span class="c1">#do not add a maximum delay bound, set 0</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">addDelaysToDisctionnaryWithoutChangingRto</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConstantPropagationDelayOutputPipelineStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.ConstantPropagationDelayOutputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">ConstantPropagationDelayOutputPipelineStep</span><span class="p">(</span><span class="n">OutputPipelineStep</span><span class="p">):</span>
    <span class="sd">""" This adds a constant propagation delay propD to all the flow States</span>

<span class="sd">    ALL THE DELAY MAX BOUNDS ARE INCREASED BY propD</span>
<span class="sd">    ALL THE DELAY MIN BOUNDS ARE INCREASED BY propD</span>
<span class="sd">    IT DOES NOT CHANGE ANY ARRIVAL CURVE</span>
<span class="sd">    """</span>

    <span class="n">propD</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
    
<div class="viewcode-block" id="ConstantPropagationDelayOutputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.ConstantPropagationDelayOutputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">minContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">maxContentionDelay</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propD</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propD</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ConstantPropagationDelayOutputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.ConstantPropagationDelayOutputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"PD"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">"prop-delay"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="ConstantPropagationDelayOutputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.ConstantPropagationDelayOutputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">propD</span> <span class="o">=</span> <span class="n">unitUtility</span><span class="o">.</span><span class="n">readTime</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"prop-delay"</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">instance</span></div></div>

<div class="viewcode-block" id="OutputPipeline"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline">[docs]</a><span class="k">class</span> <span class="nc">OutputPipeline</span><span class="p">:</span>
    <span class="c1">#order matters!</span>
    <span class="n">availableModules</span> <span class="o">=</span> <span class="p">[</span><span class="n">PacketEliminationFunctionFlowStateMergingOutputPipelineStep</span><span class="p">,</span> <span class="n">DeltaDDeconvolutionOutputPipelineStep</span><span class="p">,</span> <span class="n">FromSourceDeltaDDeconvolutionOutputPipelineStep</span><span class="p">,</span>  <span class="n">FromKeyTaggingOutputPipelineStep</span><span class="p">,</span> <span class="n">TransmissionDelayOnlyAddMinimumDelayDoNotChangeMaxDelay</span><span class="p">,</span> <span class="n">CeilBurstsOutputPipelineStep</span><span class="p">,</span> <span class="n">ConstantPropagationDelayOutputPipelineStep</span><span class="p">]</span>
    
    <span class="n">pipeline</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">OutputPipelineStep</span><span class="p">]</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">dict</span>
    
    <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">]</span>
    <span class="n">delayMinInContention</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">delayMaxInContention</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"pipeline_finished"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeName</span> <span class="o">=</span> <span class="n">nodeName</span>

<div class="viewcode-block" id="OutputPipeline.autoInstall"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.autoInstall">[docs]</a>    <span class="k">def</span> <span class="nf">autoInstall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">avType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">availableModules</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">avType</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">appendPipelineElement</span><span class="p">(</span><span class="n">avType</span><span class="o">.</span><span class="n">getConfiguredInstanceForNode</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">))</span></div>

<div class="viewcode-block" id="OutputPipeline.appendPipelineElement"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.appendPipelineElement">[docs]</a>    <span class="k">def</span> <span class="nf">appendPipelineElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pipelineElement</span><span class="p">:</span> <span class="n">OutputPipelineStep</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pipelineElement</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="OutputPipeline.setInputFlowStates"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.setInputFlowStates">[docs]</a>    <span class="k">def</span> <span class="nf">setInputFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="OutputPipeline.getOutputFlowStates"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.getOutputFlowStates">[docs]</a>    <span class="k">def</span> <span class="nf">getOutputFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">flows</span><span class="o">.</span><span class="n">FlowState</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Pipeline must be computed before calling getFinalArrivalCurve"</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="OutputPipeline.setContentionDelayBounds"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.setContentionDelayBounds">[docs]</a>    <span class="k">def</span> <span class="nf">setContentionDelayBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowerBound</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delayMinInContention</span> <span class="o">=</span> <span class="n">lowerBound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delayMaxInContention</span> <span class="o">=</span> <span class="n">upperBound</span></div>

<div class="viewcode-block" id="OutputPipeline.processPipeline"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.processPipeline">[docs]</a>    <span class="k">def</span> <span class="nf">processPipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Processes the pipeline (each step, in their order in the list of pipeline element)</span>
<span class="sd">        """</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"'pipeline_finished' must be 'False' to process the pipeline. Cannot do it twice"</span><span class="p">)</span>
        <span class="c1">#Call each step of the pipeline</span>
        <span class="n">localFlags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">localFlags</span><span class="p">[</span><span class="s2">"node_name"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeName</span>
        <span class="k">for</span> <span class="n">outputPipelineStep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="p">:</span>    
            <span class="n">outputPipelineStep</span><span class="o">.</span><span class="n">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delayMinInContention</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delayMaxInContention</span><span class="p">,</span> <span class="n">localFlags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"pipeline_finished"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="OutputPipeline.isFinished"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.isFinished">[docs]</a>    <span class="k">def</span> <span class="nf">isFinished</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="OutputPipeline.clearPipelineComputations"><a class="viewcode-back" href="../../xtfa.outputPipelines.html#xtfa.outputPipelines.OutputPipeline.clearPipelineComputations">[docs]</a>    <span class="k">def</span> <span class="nf">clearPipelineComputations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"pipeline_finished"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delayMinInContention</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delayMaxInContention</span> <span class="o">=</span> <span class="kc">None</span></div></div>


<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">networks</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Ludovic Thomas
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>