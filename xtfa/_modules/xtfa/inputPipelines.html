<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.04.07"/>
        <title>xtfa.inputPipelines - xTFA 2022-07 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=68f4518137b9aefe99b631505a2064c3c42c9852" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">xTFA 2022-07 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">xTFA 2022-07 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../relationmanuscript.html">Relations Between the Notions of the Manuscript and their Implementation in the Tool</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../modules.html">xtfa</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../xtfa.html">xtfa package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.GurobiInterface.html">xtfa.GurobiInterface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.MilpInterface.html">xtfa.MilpInterface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.baharevMfas.html">xtfa.baharevMfas module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.clocks.html">xtfa.clocks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.contentionPipelines.html">xtfa.contentionPipelines module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.fasUtility.html">xtfa.fasUtility module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.flows.html">xtfa.flows module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.graphUtility.html">xtfa.graphUtility module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.inputPipelines.html">xtfa.inputPipelines module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.lcan.html">xtfa.lcan module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.minPlusToolbox.html">xtfa.minPlusToolbox module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.networks.html">xtfa.networks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.nodes.html">xtfa.nodes module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.outputPipelines.html">xtfa.outputPipelines module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.plotUtility.html">xtfa.plotUtility module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xtfa.unitUtility.html">xtfa.unitUtility module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container"><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for xtfa.inputPipelines</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3</span>
<span class="c1">#</span>
<span class="c1"># This file is part of xTFA</span>
<span class="c1"># Copyright (c) 2021-2022 Ludovic Thomas (ISAE-SUPAERO)</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify  </span>
<span class="c1"># it under the terms of the GNU General Public License as published by  </span>
<span class="c1"># the Free Software Foundation, version 3.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but </span>
<span class="c1"># WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<span class="c1"># General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License </span>
<span class="c1"># along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">"""</span>
<span class="sd">This module contains the definition of the ACP (Aggregate Computational Pipeline)</span>
<span class="sd">In the software, the aggregate computational pipeline is called the "input pipeline" (legacy name)</span>

<span class="sd">The file is split in three parts:</span>
<span class="sd">-First, the objects for managing FlowState partitions are defined</span>
<span class="sd">-Then all the possible computational blocks inside the pipeline are defined</span>
<span class="sd">-Last the ACP itself is defined.</span>
<span class="sd">"""</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">minPlusToolbox</span> <span class="k">as</span> <span class="n">mpt</span>
<span class="kn">from</span> <span class="nn">xtfa.clocks</span> <span class="kn">import</span> <span class="n">Clock</span>
<span class="kn">from</span> <span class="nn">xtfa.flows</span> <span class="kn">import</span> <span class="n">FlowState</span><span class="p">,</span> <span class="n">Flow</span><span class="p">,</span> <span class="n">CurveNotKnown</span>
<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">unitUtility</span>



<span class="c1"># IP stands for input pipeline</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">"IP"</span><span class="p">)</span>


<span class="c1">######### PART 1: Definition of the FlowState partitions ###########</span>

<div class="viewcode-block" id="FlowsPartitionElement"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartitionElement">[docs]</a><span class="k">class</span> <span class="nc">FlowsPartitionElement</span><span class="p">:</span>
    <span class="sd">"""This class represents an element in the partition of the flow states. </span>
<span class="sd">    It references a list of flows, the group of which being shaped by the aggregateShaping curve</span>

<span class="sd">        Attributes:</span>
<span class="sd">            flows:  the list of the flow states that belong to this partition element</span>
<span class="sd">            aggregateShaping:   the Curve that shapes the aggregate in this partition element. </span>
<span class="sd">    """</span>
    <span class="n">flows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]</span>
    <span class="n">aggregateShaping</span><span class="p">:</span> <span class="n">mpt</span><span class="o">.</span><span class="n">Curve</span>
    <span class="n">flags</span><span class="p">:</span> <span class="n">Mapping</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Creates a FlowsPartitionElement with an empty list and a 'None' aggregateShaping</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<div class="viewcode-block" id="FlowsPartitionElement.copy"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartitionElement.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'FlowsPartitionElement'</span><span class="p">:</span>
        <span class="sd">"""Returns a (simple, non-deep) copy of this element. The copy is made of a copied list of the same references to the flow states and a deep copy of the shapingCurve</span>

<span class="sd">        Returns:</span>
<span class="sd">            FlowsPartitionElement: the copy</span>
<span class="sd">        """</span>
        <span class="n">newElement</span> <span class="o">=</span> <span class="n">FlowsPartitionElement</span><span class="p">()</span>
        <span class="c1">#copy list but do not copy FlowStates themselves</span>
        <span class="n">newElement</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">)</span>
        <span class="c1">#but deep copy the shaping curve</span>
        <span class="n">newElement</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newElement</span></div>

<div class="viewcode-block" id="FlowsPartitionElement.copyWithFlowStates"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartitionElement.copyWithFlowStates">[docs]</a>    <span class="k">def</span> <span class="nf">copyWithFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fsl</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">'FlowsPartitionElement'</span><span class="p">:</span>
        <span class="n">newElement</span> <span class="o">=</span> <span class="n">FlowsPartitionElement</span><span class="p">()</span>
        <span class="n">newElement</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">fsl</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">isEqualFlowByNameAllKeysMustMatch</span><span class="p">(</span><span class="n">ffs</span><span class="p">)):</span>
                    <span class="n">newElement</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span>
        <span class="n">newElement</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newElement</span></div>

<div class="viewcode-block" id="FlowsPartitionElement.getMaxPacketLengthInPartitionElement"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartitionElement.getMaxPacketLengthInPartitionElement">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxPacketLengthInPartitionElement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">"""Returns the max packet length in the aggregate of this paritition element</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: the maximum packet length among the flows associated with all the flow states in this partition element</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">maxPacketLength</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">)</span></div>

<div class="viewcode-block" id="FlowsPartitionElement.getResultingArrivalCurve"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartitionElement.getResultingArrivalCurve">[docs]</a>    <span class="k">def</span> <span class="nf">getResultingArrivalCurve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpt</span><span class="o">.</span><span class="n">Curve</span><span class="p">:</span>
        <span class="sd">"""Returns the resulting arrival curve for the aggregate of the current partition element.</span>
<span class="sd">        That is: alpha_shaping * (sum_f (alpha_f)), or again: the sum of the individual arrival curves, then shaped by the shaping curve.</span>
<span class="sd">        If the shaping curve is 'None', then only the sum is performed (no shaping)</span>

<span class="sd">        Returns:</span>
<span class="sd">            minPlusToolbox.Curve: the resulting arrival curve for this partition element</span>
<span class="sd">        """</span>
        <span class="n">sumIndividuals</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">NoCurve</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
            <span class="n">sumIndividuals</span> <span class="o">=</span> <span class="n">sumIndividuals</span> <span class="o">+</span> <span class="n">fs</span><span class="o">.</span><span class="n">getCopyInternalArrivalCurve</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sumIndividuals</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">*</span> <span class="n">sumIndividuals</span><span class="p">)</span></div></div>
    
<div class="viewcode-block" id="FlowsPartition"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition">[docs]</a><span class="k">class</span> <span class="nc">FlowsPartition</span><span class="p">:</span>
    <span class="sd">"""This class represents a partition of the flow states into partition elements</span>

<span class="sd">        Attributes:</span>
<span class="sd">            partitionElements: list of FlowsPartitionElement</span>
<span class="sd">    """</span>

    <span class="n">partitionElements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartitionElement</span><span class="p">]</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Creates a FlowsPartition with an empty list of partitionElements</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"Partition"</span>
    
<div class="viewcode-block" id="FlowsPartition.createPartitionElement"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.createPartitionElement">[docs]</a>    <span class="k">def</span> <span class="nf">createPartitionElement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FlowsPartitionElement</span><span class="p">]:</span>
        <span class="sd">"""Creates a FlowsParitionElement and ADDS it to the current partition</span>

<span class="sd">        Returns:</span>
<span class="sd">            FlowsPartitionElement: the newly created element, whose reference has been ALREADY ADDED to the current partition</span>
<span class="sd">        """</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">FlowsPartitionElement</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">el</span></div>
    
<div class="viewcode-block" id="FlowsPartition.countElementsContainingFlowState"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.countElementsContainingFlowState">[docs]</a>    <span class="k">def</span> <span class="nf">countElementsContainingFlowState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowState</span><span class="p">:</span> <span class="n">FlowState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">""" Counts the number of partition elements in the current partition that contains a reference to this flow state. NB: equality is done at reference-level, the content of the fields in flowState is NOT checked</span>

<span class="sd">        Args:</span>
<span class="sd">            flowState (flows.FlowState): the FlowState to search for</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: the number of partition elements that contain this FlowState (a reference to it)</span>
<span class="sd">        """</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flowState</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="FlowsPartition.removeFlowStateFromPartition"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.removeFlowStateFromPartition">[docs]</a>    <span class="k">def</span> <span class="nf">removeFlowStateFromPartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="n">FlowState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Removes a FlowState fs from the partition. If fs was in a partition elements with other flows, then fs is removed from the partition element. If fs was alone in a partition element, then this partition element is removed from the current partition. If fs was not in any partition element, then nothing is performed. </span>

<span class="sd">        Args:</span>
<span class="sd">            fs (flows.FlowState): the FlowState to remove from the current partition</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
                <span class="c1"># flow state found in this element, remove it</span>
                <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
                    <span class="c1">#list of flows associated with this element is empty, remove element from partition</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                <span class="c1"># we can safely exit - the flow state can only be in one partition element</span>
                <span class="k">return</span></div>

<div class="viewcode-block" id="FlowsPartition.breakPartitionByIncomingEdge"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.breakPartitionByIncomingEdge">[docs]</a>    <span class="k">def</span> <span class="nf">breakPartitionByIncomingEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Breaks the current partition depending on the incoming edge of the flows. Every element of the partition is break into several elements such that all the flows in each of the resulting elements come from the same input port (it does not mean that there will be the same number of partition elements element as the number of input ports). Example: assume partition is made of elements A = {f} and B={g,h}. Assume f and g comes from input port 1 and h comes from input port 2. Then the resulting partition is A={f},B={g},C={h}</span>
<span class="sd">        """</span>
        <span class="n">partitionElementCreated</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="c1"># define the reference edge as the incoming edge of the first flow in the partition element</span>
            <span class="n">referenceEdge</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atEdge</span>
            <span class="n">flowsToMove</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="c1">#for any other flow state (except the first one)</span>
            <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">flow</span><span class="o">.</span><span class="n">atEdge</span> <span class="o">!=</span> <span class="n">referenceEdge</span><span class="p">:</span>
                    <span class="n">flowsToMove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flowsToMove</span><span class="p">:</span>
                <span class="c1"># list is not empty</span>
                <span class="c1"># - remove flows from previous element</span>
                <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">flowsToMove</span><span class="p">:</span>
                    <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
                <span class="c1"># - create new element.</span>
                <span class="c1"># I don't use self.createPartitionElement() cause I don't want to add an element to self.partitionElements while I'm looping on it</span>
                <span class="n">newEl</span> <span class="o">=</span> <span class="n">FlowsPartitionElement</span><span class="p">()</span>
                <span class="c1"># - with flows needed to move</span>
                <span class="n">newEl</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="n">flowsToMove</span>
                <span class="c1"># - with a copy of the shaping curve</span>
                <span class="n">newEl</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="p">)</span>
                <span class="c1"># add new element to list of created element</span>
                <span class="n">partitionElementCreated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partitionElementCreated</span><span class="p">:</span>
            <span class="c1"># new partition elements have been created, add them to the partition</span>
            <span class="k">for</span> <span class="n">nel</span> <span class="ow">in</span> <span class="n">partitionElementCreated</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nel</span><span class="p">)</span>
            <span class="c1"># recursive call until all no more partition element needs to be created</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">breakPartitionByIncomingEdge</span><span class="p">()</span></div>
        <span class="c1"># if no partition element was created, return and break recursive stack</span>

<div class="viewcode-block" id="FlowsPartition.copy"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'FlowsPartition'</span><span class="p">:</span>
        <span class="sd">"""Creates a copy (level 2) of the present partition. The copy contains a new list, whose elements are each a copy of the FlowsPartitionElement that is present in the current partition. We use FlowsPartitionElement.copy() to copy the partition elements. In particular (look at the doc of FlowsPartitionElement.copy()), the flows states contained in the flow partition elements are not copied, we only copy their reference.</span>

<span class="sd">        Returns:</span>
<span class="sd">            FlowsPartition: the copy of the current partition (level 2, not a deepcopy)</span>
<span class="sd">        """</span>
        <span class="n">newPartition</span> <span class="o">=</span> <span class="n">FlowsPartition</span><span class="p">()</span>
        <span class="n">newPartition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="n">newPartition</span><span class="o">.</span><span class="n">partitionElements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">newPartition</span></div>

<div class="viewcode-block" id="FlowsPartition.copyWithFlowStates"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.copyWithFlowStates">[docs]</a>    <span class="k">def</span> <span class="nf">copyWithFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fsl</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">'FlowsPartition'</span><span class="p">:</span>
        <span class="n">newPartition</span> <span class="o">=</span> <span class="n">FlowsPartition</span><span class="p">()</span>
        <span class="n">newPartition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="n">copiedElement</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">copyWithFlowStates</span><span class="p">(</span><span class="n">fsl</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">copiedElement</span><span class="o">.</span><span class="n">flows</span><span class="p">):</span>
                <span class="n">newPartition</span><span class="o">.</span><span class="n">partitionElements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copiedElement</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newPartition</span></div>

<div class="viewcode-block" id="FlowsPartition.isPartition"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.isPartition">[docs]</a>    <span class="k">def</span> <span class="nf">isPartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">"""Checks if the current FlowsPartition is indeed a valid partition of the provided flowStates</span>

<span class="sd">        Args:</span>
<span class="sd">            flowStates (list[flows.FlowState]): a list of the FlowStates that should be partitionned</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True is the current object is a valid partition of the argument flowStates. False otherwise.</span>
<span class="sd">        """</span>
        <span class="c1">#Every fs in flowsStates must be presented once and only once</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">countElementsContainingFlowState</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1">#The partition contains no fs that is not in flowStates</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ffs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="FlowsPartition.addFixedOverheadEffect"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.addFixedOverheadEffect">[docs]</a>    <span class="k">def</span> <span class="nf">addFixedOverheadEffect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkSpeedDictionnary</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">str</span><span class="p">],</span><span class="nb">float</span><span class="p">],</span> <span class="n">overhead</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="c1">#retrieve the incoming edge associated with this partition element: take the one of the first flow in the partition element, they are all the same since we used partition.breakPartitionByIncomingEdge() beforehand</span>
            <span class="k">if</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atEdge</span> <span class="ow">in</span> <span class="n">linkSpeedDictionnary</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1">#link speed known, tighter result</span>
                <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="o">.</span><span class="n">return_curve_with_packetization</span><span class="p">(</span><span class="n">overhead</span><span class="p">,</span><span class="n">link_capacity</span><span class="o">=</span><span class="n">linkSpeedDictionnary</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atEdge</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#link speed not known, traditionnal result</span>
                <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="o">.</span><span class="n">return_curve_with_packetization</span><span class="p">(</span><span class="n">overhead</span><span class="p">)</span></div>


<div class="viewcode-block" id="FlowsPartition.addPacketizationEffect"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.addPacketizationEffect">[docs]</a>    <span class="k">def</span> <span class="nf">addPacketizationEffect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkSpeedDictionnary</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">str</span><span class="p">],</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="c1">#retrieve the incoming edge associated with this partition element: take the one of the first flow in the partition element, they are all the same since we used partition.breakPartitionByIncomingEdge() beforehand</span>
            <span class="k">if</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atEdge</span> <span class="ow">in</span> <span class="n">linkSpeedDictionnary</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1">#link speed known, tighter result</span>
                <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="o">.</span><span class="n">return_curve_with_packetization</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">getMaxPacketLengthInPartitionElement</span><span class="p">(),</span><span class="n">link_capacity</span><span class="o">=</span><span class="n">linkSpeedDictionnary</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atEdge</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#link speed not known, traditionnal result</span>
                <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span><span class="o">.</span><span class="n">return_curve_with_packetization</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">getMaxPacketLengthInPartitionElement</span><span class="p">())</span></div>


<div class="viewcode-block" id="FlowsPartition.getResultingArrivalCurve"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.FlowsPartition.getResultingArrivalCurve">[docs]</a>    <span class="k">def</span> <span class="nf">getResultingArrivalCurve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpt</span><span class="o">.</span><span class="n">Curve</span><span class="p">:</span>
        <span class="sd">"""Returns the resulting arrival curve for this partition. The resulting arrival curve is defined as the sum of the resulting arrival curves of each of the element in the partitionElements</span>

<span class="sd">        Returns:</span>
<span class="sd">            minPlusToolbox.Curve: the resulting arrival curve</span>
<span class="sd">        """</span>
        <span class="n">thisPartitionCurve</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">NoCurve</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionElements</span><span class="p">:</span>
            <span class="n">thisPartitionCurve</span> <span class="o">=</span> <span class="n">thisPartitionCurve</span> <span class="o">+</span> <span class="n">el</span><span class="o">.</span><span class="n">getResultingArrivalCurve</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">thisPartitionCurve</span></div></div>

<span class="c1">######## PART 2: Definition of the computational blocks in the pipeline ##########</span>

<span class="c1">#The two static methods checkInstall and getConfiguredInstanceForNode are used for the auto configuration of the pipeline.</span>
<span class="c1">#The idea of the auto configuration is that when the input pipeline of a node is instanciated, for each possible computational block (each subclass of InputPipelineStep), we check whether an instance of this block should be added to the pipeline, based on a set of flags.</span>
<span class="c1">#See the checkInstall method documentation for each subclass of InputPipelineStep</span>

<div class="viewcode-block" id="InputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">InputPipelineStep</span><span class="p">:</span>
    <span class="sd">"""This interface represents a computational steps that:</span>
<span class="sd">            - May modify the flow states</span>
<span class="sd">            - May group flows into aggregates that are then shaped by a curve. For this it can change existing partitions by modifying/breaking/creating new partition elements in the existing partitions, or it can created a new partition.</span>
<span class="sd">    """</span>
    <span class="n">_nodeName</span><span class="p">:</span> <span class="nb">str</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span> <span class="o">=</span> <span class="n">nodeName</span>

<div class="viewcode-block" id="InputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""This function MUST be overwritten by the implementation. </span>
<span class="sd">        It executes the computationnal step. </span>
<span class="sd">        The step SHOULD MODIFY the object referenced by the arguments and return nothing.</span>

<span class="sd">        Args:</span>
<span class="sd">            flowStates (list[FlowState]): the list of the flow states as they are at the output of the previous element in the input pipeline (or if the current object is the first step in the input pipeline, this is the list of the flow states as they enter the node). The current object may modify these flow states, they are then provided to the next step in the input pipeline.</span>
<span class="sd">            partitions (list[FlowsPartition]): the list of all the current existing partitions of the flows as they appear at the output of the previous step in the input pipeline. The current object may modify this list, which is then provided to the next step.</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputPipelineStep.clearComputations"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipelineStep.clearComputations">[docs]</a>    <span class="k">def</span> <span class="nf">clearComputations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        This function clears the computations of the pipeline computationnal block, in cas it saved temporary variables.</span>
<span class="sd">        It can be overwritten and SHALL be overwritten by any block that stores local results.</span>
<span class="sd">        """</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="InputPipelineStep.checkAllPartitions"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipelineStep.checkAllPartitions">[docs]</a>    <span class="k">def</span> <span class="nf">checkAllPartitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">],</span> <span class="n">flowStates</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]):</span>
        <span class="sd">"""Utility class (no border effect) that checks if a list of partitions is indeed a list of partitions of all the flow states</span>

<span class="sd">        Args:</span>
<span class="sd">            partitions (List[FlowsPartition]): List of partitions to check</span>
<span class="sd">            flowStates (List[FlowState]): The list of flow states (each partition shall contain each flow state)</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: Error raised when one of the partitions is invalid.</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span> <span class="p">(</span><span class="s2">"Invalid partition"</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="InputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">"""This class function MUST be overwritten by the implementation. It checks if an instance for the current class should be installed on the input pipeline of the considered node. To make this decision, it can rely on the arguments that give the name and the computationnal flags associated with this node, as well as a reference to the entire network, shoudl the installation of the input pipeline step depend on some properties of other nodes or of the flows. The method MUST NOT modify the arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            compuFlags (Mapping): a dictionnary that gives the computationnal flags for this node</span>
<span class="sd">            net (networks.Network): a reference to the network</span>
<span class="sd">            nodeName (str): the name of the node</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if an instance of the class should be installed in the input pipeline for this node, False otherwise.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="InputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'InputPipelineStep'</span><span class="p">:</span>
        <span class="sd">""" This class function MUST be overwritten by the implementation IF checkInstall is susceptible to answer True. Returns a configured instance of the current class to be added as an input pipeline step for the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            compuFlags (Mapping): a dictionnary that gives the computationnal flags for this node</span>
<span class="sd">            net (networks.Network): a reference to the network</span>
<span class="sd">            nodeName (str): the name of the node</span>

<span class="sd">        Returns:</span>
<span class="sd">            InputPipelineStep: the configured instance, that will then be appended to the input pipeline for this node.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div></div>

<div class="viewcode-block" id="InputPortShapingInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPortShapingInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">InputPortShapingInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This implementation of InputPipelineStep represents the effect of the input line shaping on the incoming flows. Specifically, it creates a new parition for each input port that contains the flowstates coming from this input port, and to each partition element, it associates the shaping curve that corresponds to this input port.</span>
<span class="sd">    """</span>
    
    <span class="n">flagThatTriggersInstallation</span> <span class="o">=</span> <span class="s2">"input-shaping"</span>
    <span class="n">abbrvInTechnoThatTriggersInstallation</span> <span class="o">=</span> <span class="s2">"IS"</span>
    <span class="n">_shapingCurves</span><span class="p">:</span> <span class="nb">dict</span>

<div class="viewcode-block" id="InputPortShapingInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPortShapingInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" In this implementation, we answer yes if:</span>
<span class="sd">                - (either a flag input-shaping="True" is found in the computationnal flags)</span>
<span class="sd">                - (PREVIOUS) OR (the abbreviation "IS" is in the technology flags of the computationnal flags)</span>
<span class="sd">                - (ALL THE PREVIOUS) AND (the node as at least one incoming edge in the ODG (output port dependency graph))</span>

<span class="sd">        Args:</span>
<span class="sd">            compuFlags (Mapping): a dictionnary that gives the computationnal flags for this node</span>
<span class="sd">            net (networks.Network): a reference to the network</span>
<span class="sd">            nodeName (str): the name of the node</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if an instance of the class should be installed in the input pipeline for this node, False otherwise.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">nodeName</span><span class="p">))):</span>
            <span class="c1"># the node has no predecessor, so no incoming flow is expected, do not install</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">flagThatTriggersInstallation</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="c1">#flag found</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">abbrvInTechnoThatTriggersInstallation</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="c1">#abbreviation 'IS' found</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"packet-elimination-function"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"ISNPE"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputPortShapingInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPortShapingInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputPipelineStep</span><span class="p">:</span>
        <span class="sd">""" In this implementation, the InputPortShapingInputPipelineStep is configured by filling the _shapingCurves attribute, which is done by looking at the flag 'transmission-capacity' of the previous nodes</span>
<span class="sd">        """</span>
        <span class="n">step</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prevNode</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">nodeName</span><span class="p">):</span>
            <span class="n">linkSpeed</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prevNode</span><span class="p">][</span><span class="s2">"computational_flags"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"transmission-capacity"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">):</span>
                <span class="n">linkSpeed</span> <span class="o">=</span> <span class="n">unitUtility</span><span class="o">.</span><span class="n">readRate</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">)</span>
                <span class="c1"># the shaping curve is a gamma_c curve, which is the same as a leakybucket with no burst</span>
                <span class="n">shapingCurve</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">LeakyBucket</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">setShapingCurveForIncommingEdge</span><span class="p">((</span><span class="n">prevNode</span><span class="p">,</span><span class="n">nodeName</span><span class="p">),</span> <span class="n">shapingCurve</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#setting none is the way to tell 'no shaping'</span>
                <span class="n">step</span><span class="o">.</span><span class="n">setShapingCurveForIncommingEdge</span><span class="p">((</span><span class="n">prevNode</span><span class="p">,</span><span class="n">nodeName</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">step</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Creates an InputPortShapingInputPipelineStep with an empty dictionnary for _shapingCurves</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shapingCurves</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<div class="viewcode-block" id="InputPortShapingInputPipelineStep.setShapingCurveForIncommingEdge"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPortShapingInputPipelineStep.setShapingCurveForIncommingEdge">[docs]</a>    <span class="k">def</span> <span class="nf">setShapingCurveForIncommingEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">shapingCurve</span><span class="p">:</span> <span class="n">mpt</span><span class="o">.</span><span class="n">Curve</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Sets the shaping curve for the input port that corresponds to the provided edge in the ODG (Output port dependency graph)</span>

<span class="sd">        Args:</span>
<span class="sd">            edge: The edge in the ODG that corresponds to the input port</span>
<span class="sd">            shapingCurve (minPlusToolbox.Curve): The curve shaping the aggregate from this input port, or None if no shaping for this edge (&lt;=&gt; shaping with an infinite curve)</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shapingCurves</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">shapingCurve</span></div>
    
<div class="viewcode-block" id="InputPortShapingInputPipelineStep.overrideAllShapingCurvesForAlreadyConfiguredEdges"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPortShapingInputPipelineStep.overrideAllShapingCurvesForAlreadyConfiguredEdges">[docs]</a>    <span class="k">def</span> <span class="nf">overrideAllShapingCurvesForAlreadyConfiguredEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newShapingCurve</span><span class="p">:</span> <span class="n">mpt</span><span class="o">.</span><span class="n">Curve</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shapingCurves</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shapingCurves</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">newShapingCurve</span></div>

<div class="viewcode-block" id="InputPortShapingInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPortShapingInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Executes the InputPortShapingInputPipelineStep step. See documentation of super class</span>
<span class="sd">        """</span>
        <span class="c1"># input shaping does not modify flow states:</span>
        <span class="c1"># no delay penalty (input shaping is for free)</span>
        
        <span class="c1"># input shaping does not need to modify existing partitions (input shaping is for freee), let's create a new partition</span>
        <span class="c1"># first, create the dic (edge) -&gt; (list of flow states on this edge)</span>
        <span class="n">repartition</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repartition</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1">#edge does not exists in dict, create</span>
                <span class="n">repartition</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">repartition</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1">#now, create the new partition</span>
        <span class="n">newPartition</span> <span class="o">=</span> <span class="n">FlowsPartition</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">repartition</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># for each edge, create a partition element that contains the flow states comming from this edge and with shaping curve the one stored</span>
            <span class="n">partEl</span> <span class="o">=</span> <span class="n">newPartition</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
            <span class="n">partEl</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shapingCurves</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">partEl</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="n">repartition</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">newPartition</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"not a valid partition"</span><span class="p">)</span>
        <span class="n">newPartition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"InputShaping"</span>
        <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPartition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PacketizationInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketizationInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">PacketizationInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This implementation of InputPipelineStep represents the effect of the packetizers located on the input ports of the network switch. Specifically, it:</span>
<span class="sd">        - adds the packetization effect to all the flowstates (ie to the individual arrival curves)</span>
<span class="sd">        - it breaks the already existing partitions (if any) depending on the input port of the flows (if required), and then it adds the packetization effect to any shapingcurve in any partition element in any of the already existing partitions.</span>
<span class="sd">        - this step does not create a new partition, it modifies the existing ones.</span>
<span class="sd">    """</span>

    <span class="n">_inputLinkSpeed</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="n">abbrvInTechnoThatTriggersInstallation</span> <span class="o">=</span> <span class="s2">"PK"</span>

<div class="viewcode-block" id="PacketizationInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketizationInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" Returns True if the abbreviation 'PK' is in the 'technology' flag of the compuFlags dict AND if the node has at least one predecessor</span>
<span class="sd">        """</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">abbrvInTechnoThatTriggersInstallation</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">nodeName</span><span class="p">))):</span>
                <span class="c1"># the node has predecessors, so incoming flows are expected, install</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span></div>

<div class="viewcode-block" id="PacketizationInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketizationInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputPipelineStep</span><span class="p">:</span>
        <span class="sd">""" Returns a configured instance. Configuration is performed by filling in the _inputLinkSpeed dictionnary attribute, by looking at the 'transmission-capacity' computationnal flag of the previous nodes</span>
<span class="sd">        """</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">PacketizationInputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prevNode</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">nodeName</span><span class="p">):</span>
            <span class="n">linkSpeed</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prevNode</span><span class="p">][</span><span class="s2">"computational_flags"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"transmission-capacity"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">):</span>
                <span class="n">linkSpeed</span> <span class="o">=</span> <span class="n">unitUtility</span><span class="o">.</span><span class="n">readRate</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">setLinkSpeedForIncommingEdge</span><span class="p">((</span><span class="n">prevNode</span><span class="p">,</span><span class="n">nodeName</span><span class="p">),</span> <span class="n">linkSpeed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">step</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<div class="viewcode-block" id="PacketizationInputPipelineStep.getEdgeListInLinkSpeedDictionnary"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketizationInputPipelineStep.getEdgeListInLinkSpeedDictionnary">[docs]</a>    <span class="k">def</span> <span class="nf">getEdgeListInLinkSpeedDictionnary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="PacketizationInputPipelineStep.setLinkSpeedForIncommingEdge"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketizationInputPipelineStep.setLinkSpeedForIncommingEdge">[docs]</a>    <span class="k">def</span> <span class="nf">setLinkSpeedForIncommingEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">str</span><span class="p">],</span> <span class="n">linkSpeed</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Sets the speed of the link connected to the input port represented by the provided edge. If provided, this information is used to compute a tighter packetization effect.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge (Tuple[str,str]): An edge in the ODG (output port dependency graph)</span>
<span class="sd">            linkSpeed (float): the speed of the link that is connected to the input port represented by the provided edge.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">linkSpeed</span></div>
    
<div class="viewcode-block" id="PacketizationInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketizationInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># packetization:</span>
        <span class="c1"># - adds the packetization effect to the individual arrival curves</span>
        <span class="c1"># - but does not add any penalty on the delay or RTO (packetization does not increase ETE delay bounds, except that it increases burstiness of flows)</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1">#link speed is known, can be used for improving packetization effect</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"internal-penalty"</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_packetization_penalty_curve</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">maxPacketLength</span><span class="p">,</span> <span class="n">link_capacity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#link speed not known tradditionnal packetization effect</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"internal-penalty"</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_packetization_penalty_curve</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">maxPacketLength</span><span class="p">)</span>
        <span class="c1">#Now we need to apply the packetization to all the previously known shaping curves that are part of a partition</span>
        <span class="c1">#Each aggregate coming from a an input port is packetized differently, so we first need to make sure that:</span>
        <span class="c1"># FOR ALL partition, EACH element of the partition ONLY CONTAINS flow states from the same edge</span>
        <span class="c1">#so we will first break the partitions accordingly</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">breakPartitionByIncomingEdge</span><span class="p">()</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">partition</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"not a valid partition"</span><span class="p">)</span>
        <span class="c1"># at this point we know that:</span>
        <span class="c1"># for each partition,</span>
        <span class="c1">#   for each element of this partition</span>
        <span class="c1">#       the aggregate made of the flows in this element goes through the SAME packetizer,</span>
        <span class="c1">#       so we can safely add the packetization effect to the shaping curve of every partition element</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">addPacketizationEffect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="p">)</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"+"</span> <span class="o">+</span> <span class="s2">"Packetization"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="CutThroughInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.CutThroughInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">CutThroughInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This implementation of InputPipelineStep represents the effect of the packetizers located on the input ports of the network switch. Specifically, it:</span>
<span class="sd">        - adds the packetization effect to all the flowstates (ie to the individual arrival curves)</span>
<span class="sd">        - it breaks the already existing partitions (if any) depending on the input port of the flows (if required), and then it adds the packetization effect to any shapingcurve in any partition element in any of the already existing partitions.</span>
<span class="sd">        - this step does not create a new partition, it modifies the existing ones.</span>
<span class="sd">    """</span>

    <span class="n">_inputLinkSpeed</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="n">abbrvInTechnoThatTriggersInstallation</span> <span class="o">=</span> <span class="s2">"CT"</span>
    <span class="n">overhead</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="CutThroughInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.CutThroughInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" Returns True if the abbreviation 'CT' is in the 'technology' flag of the compuFlags dict AND if the node has at least one predecessor</span>
<span class="sd">        """</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">abbrvInTechnoThatTriggersInstallation</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">nodeName</span><span class="p">))):</span>
                <span class="c1"># the node has predecessors, so incoming flows are expected, install</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span></div>

<div class="viewcode-block" id="CutThroughInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.CutThroughInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputPipelineStep</span><span class="p">:</span>
        <span class="sd">""" Returns a configured instance. Configuration is performed by filling in the _inputLinkSpeed dictionnary attribute, by looking at the 'transmission-capacity' computationnal flag of the previous nodes</span>
<span class="sd">        """</span>
        <span class="n">step</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prevNode</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">nodeName</span><span class="p">):</span>
            <span class="n">linkSpeed</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prevNode</span><span class="p">][</span><span class="s2">"computational_flags"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"transmission-capacity"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">):</span>
                <span class="n">linkSpeed</span> <span class="o">=</span> <span class="n">unitUtility</span><span class="o">.</span><span class="n">readRate</span><span class="p">(</span><span class="n">linkSpeed</span><span class="p">)</span>
                <span class="n">step</span><span class="o">.</span><span class="n">setLinkSpeedForIncommingEdge</span><span class="p">((</span><span class="n">prevNode</span><span class="p">,</span><span class="n">nodeName</span><span class="p">),</span> <span class="n">linkSpeed</span><span class="p">)</span>
        <span class="n">step</span><span class="o">.</span><span class="n">overhead</span> <span class="o">=</span> <span class="n">unitUtility</span><span class="o">.</span><span class="n">readDataUnit</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">gif</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prevNode</span><span class="p">][</span><span class="s2">"computational_flags"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"header-size"</span><span class="p">,</span> <span class="s2">"30B"</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">step</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overhead</span> <span class="o">=</span> <span class="mi">16</span><span class="o">*</span><span class="mi">8</span>
<div class="viewcode-block" id="CutThroughInputPipelineStep.getEdgeListInLinkSpeedDictionnary"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.CutThroughInputPipelineStep.getEdgeListInLinkSpeedDictionnary">[docs]</a>    <span class="k">def</span> <span class="nf">getEdgeListInLinkSpeedDictionnary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="CutThroughInputPipelineStep.setLinkSpeedForIncommingEdge"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.CutThroughInputPipelineStep.setLinkSpeedForIncommingEdge">[docs]</a>    <span class="k">def</span> <span class="nf">setLinkSpeedForIncommingEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">str</span><span class="p">],</span> <span class="n">linkSpeed</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Sets the speed of the link connected to the input port represented by the provided edge. If provided, this information is used to compute a tighter packetization effect.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge (Tuple[str,str]): An edge in the ODG (output port dependency graph)</span>
<span class="sd">            linkSpeed (float): the speed of the link that is connected to the input port represented by the provided edge.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">linkSpeed</span></div>
    
<div class="viewcode-block" id="CutThroughInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.CutThroughInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># packetization:</span>
        <span class="c1"># - adds the packetization effect to the individual arrival curves</span>
        <span class="c1"># - but does not add any penalty on the delay or RTO (packetization does not increase ETE delay bounds, except that it increases burstiness of flows)</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1">#link speed is known, can be used for improving packetization effect</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"internal-penalty"</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_packetization_penalty_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overhead</span><span class="p">,</span> <span class="n">link_capacity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#link speed not known tradditionnal packetization effect</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"internal-penalty"</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_packetization_penalty_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overhead</span><span class="p">)</span>
        <span class="c1">#Now we need to apply the packetization to all the previously known shaping curves that are part of a partition</span>
        <span class="c1">#Each aggregate coming from a an input port is packetized differently, so we first need to make sure that:</span>
        <span class="c1"># FOR ALL partition, EACH element of the partition ONLY CONTAINS flow states from the same edge</span>
        <span class="c1">#so we will first break the partitions accordingly</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">breakPartitionByIncomingEdge</span><span class="p">()</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">partition</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"not a valid partition"</span><span class="p">)</span>
        <span class="c1"># at this point we know that:</span>
        <span class="c1"># for each partition,</span>
        <span class="c1">#   for each element of this partition</span>
        <span class="c1">#       the aggregate made of the flows in this element goes through the SAME packetizer,</span>
        <span class="c1">#       so we can safely add the packetization effect to the shaping curve of every partition element</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">addFixedOverheadEffect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputLinkSpeed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overhead</span><span class="p">)</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"+"</span> <span class="o">+</span> <span class="s2">"CutThrough"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>
             
<div class="viewcode-block" id="InitialPerInputPortAggregatorInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InitialPerInputPortAggregatorInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">InitialPerInputPortAggregatorInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This implementation of InputPipelineStep is always the first computational block in any pipeline (see the exception for development purposes in checkInstall).</span>
<span class="sd">    It groups the flow states per their input port and "shapes" them by the sum of their arrival curves.</span>
<span class="sd">    This step is important for all the computational block that MODIFIES the exiting partitions rather than creating new partitions.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>

<div class="viewcode-block" id="InitialPerInputPortAggregatorInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InitialPerInputPortAggregatorInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">repartition</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repartition</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1">#edge does not exists in dict, create</span>
                <span class="n">repartition</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">repartition</span><span class="p">[</span><span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">newPartition</span> <span class="o">=</span> <span class="n">FlowsPartition</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">repartition</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">newEl</span> <span class="o">=</span> <span class="n">newPartition</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
            <span class="n">shapingCurve</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">NoCurve</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">repartition</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                <span class="n">shapingCurve</span> <span class="o">=</span> <span class="n">shapingCurve</span> <span class="o">+</span> <span class="n">fs</span><span class="o">.</span><span class="n">getCopyInternalArrivalCurve</span><span class="p">()</span>
                <span class="n">newEl</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">newEl</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">shapingCurve</span>
        <span class="n">newPartition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"DummySum"</span>
        <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPartition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="InitialPerInputPortAggregatorInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InitialPerInputPortAggregatorInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">"""This module is always installed unless the compuFlags contain the flag "start_from_infinite" set to "true"</span>

<span class="sd">        Args:</span>
<span class="sd">            compuFlags (Mapping): the computational flags</span>
<span class="sd">            net (networks.Network): the network</span>
<span class="sd">            nodeName (str): the name of the node</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: true if the block should be instanciated, false otherwise</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"start_from_infinite"</span><span class="p">,</span><span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"true"</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="InitialPerInputPortAggregatorInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InitialPerInputPortAggregatorInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'InputPipelineStep'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">InitialPerInputPortAggregatorInputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span></div></div>
    
<div class="viewcode-block" id="LocalSourceApplicationsInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.LocalSourceApplicationsInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">LocalSourceApplicationsInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This implementation of InputPipelineStep represents the internal application that locally generate packets</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _localSourceFlowStates (List[FlowState]): the list of the flow states at the output of their respective application (BEFORE the first output port in their path)</span>
<span class="sd">    """</span>
    
    <span class="n">_localSourceFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Creates a LocalSourceApplicationsInputPipelineStep with an empty _localSourceFlowStates list</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_localSourceFlowStates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<div class="viewcode-block" id="LocalSourceApplicationsInputPipelineStep.addSourceFlowState"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.LocalSourceApplicationsInputPipelineStep.addSourceFlowState">[docs]</a>    <span class="k">def</span> <span class="nf">addSourceFlowState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="n">FlowState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Adds a flow state to the list of locally generated flows</span>

<span class="sd">        Args:</span>
<span class="sd">            fs (FlowState): the flow state (state of the flow at the output of its generating application)</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_localSourceFlowStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LocalSourceApplicationsInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.LocalSourceApplicationsInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" We answer yes if at least one flow has 'nodeName' as a source</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodeName</span> <span class="ow">in</span> <span class="n">flow</span><span class="o">.</span><span class="n">sources</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="LocalSourceApplicationsInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.LocalSourceApplicationsInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputPipelineStep</span><span class="p">:</span>
        <span class="sd">""" We configure the instance by populating the internal list of flow states</span>
<span class="sd">        """</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">LocalSourceApplicationsInputPipelineStep</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">flows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodeName</span> <span class="ow">in</span> <span class="n">flow</span><span class="o">.</span><span class="n">sources</span><span class="p">:</span>
                <span class="c1">#create new flow state</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="n">FlowState</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">sourceArrivalCurve</span>
                <span class="c1">#NO COPY of the arrival curve, this is important if we want to change the arrival curve after the installation of</span>
                <span class="c1">#micromodels</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">atEdge</span> <span class="o">=</span> <span class="s2">"source"</span>
                <span class="c1">#set the flow state on the graph</span>
                <span class="n">flow</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nodeName</span><span class="p">][</span><span class="s2">"local_source_fs"</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">Clock</span><span class="p">(</span><span class="s2">"H-"</span><span class="o">+</span><span class="n">nodeName</span><span class="p">)</span>
                <span class="c1">#and add the flow state to this pipeline step</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">changeClock</span><span class="p">(</span><span class="n">Clock</span><span class="p">(</span><span class="s2">"tai"</span><span class="p">))</span>
                <span class="n">step</span><span class="o">.</span><span class="n">addSourceFlowState</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">step</span></div>

<div class="viewcode-block" id="LocalSourceApplicationsInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.LocalSourceApplicationsInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">newFsInTAI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_localSourceFlowStates</span>
                
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">newFsInTAI</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="p">,</span><span class="n">mpt</span><span class="o">.</span><span class="n">LeakyBucket</span><span class="p">)):</span>
                <span class="c1">#initialize data for adam</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"adam-data"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"adam-data"</span><span class="p">][</span><span class="s2">"r2"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span> <span class="o">*</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_rate</span><span class="p">()</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"adam-data"</span><span class="p">][</span><span class="s2">"b2"</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">Clock</span><span class="o">.</span><span class="n">ETA</span> <span class="o">*</span> <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span><span class="o">.</span><span class="n">get_rate</span><span class="p">())</span>
        
        <span class="c1"># add all new flow states</span>
        <span class="n">flowStates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">newFsInTAI</span><span class="p">)</span>
        <span class="c1"># group them into a single element in any partition</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">newEl</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
            <span class="n">newEl</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="n">newFsInTAI</span>
            <span class="c1"># no shaping curve (assuming internal stack can send as fast as the applications do)</span>
            <span class="n">newEl</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">partition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"+"</span> <span class="o">+</span> <span class="s2">"LocalSources"</span>    
        <span class="c1">#if there was no partition, create one</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">partitions</span><span class="p">):</span>
            <span class="n">newP</span> <span class="o">=</span> <span class="n">FlowsPartition</span><span class="p">()</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">newP</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
            <span class="n">el</span><span class="o">.</span><span class="n">flows</span> <span class="o">=</span> <span class="n">newFsInTAI</span>
            <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">newP</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"LocalSources"</span>
            <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PacketEliminationFunctionInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">PacketEliminationFunctionInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This implementation of InputPipelineStep represents the effect of the packet elimination functions on the aggregate arrival curve.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _selectiveMerge(bool): True if only some flows need to be merged, False if all flows are merged</span>
<span class="sd">        _flowsToMerge(Set[Flow]): If _selectiveMerge == True, this set contains the flows that are to be merged</span>
<span class="sd">        _nodeName(str): the name of the node</span>
<span class="sd">    """</span>
    
    <span class="n">_selectiveMerge</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_flowsToMerge</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Flow</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aNodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Initialize with no selective merge</span>

<span class="sd">        Args:</span>
<span class="sd">            aNodeName (ste): the name of the node</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selectiveMerge</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">aNodeName</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_countFlowInFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="n">Flow</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">"""Counts the number of flow states in the list 'flowStates' that represents the state of the flow 'flow'</span>

<span class="sd">        Args:</span>
<span class="sd">            flow (Flow): the flow state to search/look for</span>
<span class="sd">            flowStates (List[FlowState]): the list of flow states in which to search</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: the result</span>
<span class="sd">        """</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flow</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">_getSetOfFlowsToMerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Flow</span><span class="p">]:</span>
        <span class="sd">""" Returns the set of Flow instances for which they are stictly more than one flow state to merge together. If selective merge is enabled, only the flow that are in the selective merge list are returned. </span>

<span class="sd">        Args:</span>
<span class="sd">            flowStates (List[FlowState]): the list of flow states, potentially containing several flow states for a same flow</span>

<span class="sd">        Returns:</span>
<span class="sd">            Set[Flow]: the set of flows for which we need to merge the flow states</span>
<span class="sd">        """</span>
        <span class="n">flowsToMerge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Count the number of flows for which we observe strictly more than one flow state -&gt; means the flow has been duplicated and is potentially to be merged</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_countFlowInFlowStates</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">flowsToMerge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="c1"># Intersect with the limiting list of flows to merge for this specific step</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selectiveMerge</span><span class="p">):</span>
            <span class="n">flowsToMerge</span> <span class="o">=</span> <span class="n">flowsToMerge</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flowsToMerge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flowsToMerge</span>

    <span class="k">def</span> <span class="nf">_getClosestKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graphOfFlow</span><span class="p">:</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">sourceKeys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">""" Returns the node name in 'sourceKeys' that is the closest ancestor to self._nodeName in the graph 'graphOfFlow'.</span>

<span class="sd">        Args:</span>
<span class="sd">            graphOfFlow (networkx.DiGraph): the graph of the flow</span>
<span class="sd">            sourceKeys (List[str]): a list of keys, we will return the one that corresponds to the closest ancestor of self._nodeName</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the closest ancestor in graphOfFlow</span>
<span class="sd">        """</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">sourceKeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sourceKeys</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">):</span>
                <span class="c1"># This key cannot strictly be closer than the current candidate</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">):</span>
                <span class="c1"># The candidate cannot strictly be closer than the current key</span>
                <span class="c1"># so we can flip</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">continue</span>
            <span class="c1"># Here, neither 'key' nor 'candidate' can be equal to 'source' so they are valid node names in the flow graph</span>
            <span class="n">distance_candidate</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graphOfFlow</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">candidate</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
            <span class="n">distance_key</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graphOfFlow</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">distance_key</span> <span class="o">&lt;</span> <span class="n">distance_candidate</span><span class="p">):</span>
                <span class="c1"># key is closer than candidate, flip</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">candidate</span>

    <span class="k">def</span> <span class="nf">_filterFlowStatesForAFlow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">flow</span><span class="p">:</span> <span class="n">Flow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]:</span>
        <span class="sd">""" Returns the flow states in 'flowStates' that belong to the flow 'flow'</span>

<span class="sd">        Args:</span>
<span class="sd">            flowStates (List[FlowState]): the list of flow states in which to select the flow states belonging to the flow</span>
<span class="sd">            flow (Flow): the flow to search</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[FlowState]: the list of the flow states belonging to flow 'flow' and in the list 'flowStates'</span>
<span class="sd">        """</span>
        <span class="n">flowStatesForThisFlow</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1">#get the list of flowStates</span>
        <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">.</span><span class="n">flow</span> <span class="o">==</span> <span class="n">flow</span><span class="p">):</span>
                <span class="n">flowStatesForThisFlow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flowStatesForThisFlow</span>
            

<div class="viewcode-block" id="PacketEliminationFunctionInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" In this implementation, we will:</span>
<span class="sd">            - For each already existing partition:</span>
<span class="sd">                - Create a new partition made of copy of the partition, but we have removed the flow states from the same flow from the partitions elements they were in, we have grouped them together, and we have set the shaping function as the right hand-side of the packet elimination output arrival curve theorem.</span>
<span class="sd">        """</span>
        <span class="n">addedPartitions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="c1">#We will keep the partition intact (we can do it because the packet elimination function only removes packet without adding any jitter)</span>
            <span class="c1">#So it doesnt change any property of the aggregated traffic</span>
            <span class="c1">#so let's copy it</span>
            <span class="n">newPartition</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">listFlowMerge</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSetOfFlowsToMerge</span><span class="p">(</span><span class="n">flowStates</span><span class="p">))</span>
            <span class="n">orderedList</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">listFlowMerge</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="n">orderedList</span><span class="p">:</span>
                <span class="c1"># get all the related flow states</span>
                <span class="n">flowStatesForThisFlow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filterFlowStatesForAFlow</span><span class="p">(</span><span class="n">flowStates</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
                <span class="c1"># Now, we need to obtain the min_i(d_i) and the max_i(D_i) for all the flow states, </span>
                <span class="c1"># To do so, we will interesect the 'from' keys for each flow states:</span>
                <span class="n">fromKeys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                    <span class="n">fromKeys</span> <span class="o">=</span> <span class="n">fromKeys</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ffs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="c1">#Now, we select the closest key</span>
                <span class="n">shapingCurve</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">InfiniteCurve</span><span class="p">()</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fromKeys</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"More than one ancestor have been detected - The results are not valid if the network has cyclic dependencies"</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">kkey</span> <span class="ow">in</span> <span class="n">fromKeys</span><span class="p">:</span>
                    <span class="c1">#we retrieve the arrival curve at the output of the key</span>
                    <span class="n">arrivalCurveAtDivergencePoint</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="n">kkey</span><span class="p">)</span>
                    <span class="c1">#and compute the min/max delay between the closest key and the current nationFunctionode</span>
                    <span class="n">dmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">kkey</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
                    <span class="n">dmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">kkey</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
                    <span class="c1"># and we compute the [alpha_previous (deconvolution) delta_{dmax-dmin}]</span>
                    <span class="n">shapingCurve</span> <span class="o">=</span> <span class="n">shapingCurve</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrivalCurveAtDivergencePoint</span> <span class="o">/</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span><span class="p">))</span>
                <span class="c1">#In this new partitition which is for the moment the reflect of the previous partition, we need to remove the flow states from any partition elements they were in</span>
                <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                    <span class="n">newPartition</span><span class="o">.</span><span class="n">removeFlowStateFromPartition</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                <span class="c1"># Now create a new partition element and add the flow states</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">newPartition</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                    <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">shapingCurve</span>
                <span class="n">el</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"is_ancestor_deconvolution_partition_element"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># mark the element as the one relative to the ancestor deconvolution - can be useful for reordering function</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">newPartition</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"not a valid partition"</span><span class="p">)</span>
            <span class="n">newPartition</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">newPartition</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"+"</span> <span class="o">+</span> <span class="s2">"PacketElimination"</span>
            <span class="n">addedPartitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newPartition</span><span class="p">)</span>
            <span class="c1"># And now add all the newly created partitions to partitions</span>
        <span class="n">partitions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">addedPartitions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div>

<div class="viewcode-block" id="PacketEliminationFunctionInputPipelineStep.checkTechno"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionInputPipelineStep.checkTechno">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkTechno</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"PE"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">"SPE"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">)))</span></div>

<div class="viewcode-block" id="PacketEliminationFunctionInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" In this implementation (see also superclass documentation) we answer 'yes' if "packet-elimination-function" is a key in the compuFlags</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">checkTechno</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"remove-input-pipeline-frer"</span><span class="p">,</span><span class="s2">""</span><span class="p">)</span> <span class="o">==</span> <span class="s2">"True"</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"packet-elimination-function"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PacketEliminationFunctionInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InputPipelineStep</span><span class="p">:</span>
        <span class="sd">""" In this implementation (see also superclass documentation), we create and return a configured instance. If the "packet-elimination-function" flag is at 'all', then we do not configure selective selective merge. If "packet-elimination-function" is a comma-separated list of flow names, we configure selective merge for the flows that have these names.</span>
<span class="sd">        """</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"packet-elimination-function"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"all"</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">instance</span>
        <span class="c1"># selective mode enabled</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_selectiveMerge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">flowMergeStr</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"packet-elimination-function"</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">","</span><span class="p">)</span>
        <span class="c1">#search for the flow objects that have these names</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_flowsToMerge</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">flows</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">flowMergeStr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">instance</span></div></div>


<div class="viewcode-block" id="RegulatorInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.RegulatorInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">RegulatorInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    This computational block represent either:</span>
<span class="sd">        - an Interleaved Regulator placed after a FIFO system</span>
<span class="sd">        - or a PFR placed after a FIFO system</span>
<span class="sd">        - of a PFR not placed after a FIFO system</span>
<span class="sd">    Note that IR after a non-FIFO system is not supported but no test will check it.</span>
<span class="sd">    groups: A mapping between a set of flow names and the name of the reference point that defines the arrival curves that should be enforced.</span>

<span class="sd">    Inheritance:</span>
<span class="sd">        InputPipelineStep:</span>

<span class="sd">    """</span>
    
    
    
    
    <span class="n">groups</span> <span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">pofIsPresentBefore</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">clockAdaptationMode</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">adamMargin</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pofIsPresentBefore</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span> <span class="o">=</span> <span class="s2">"none"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adamMargin</span> <span class="o">=</span> <span class="mf">1.05</span>
    
<div class="viewcode-block" id="RegulatorInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.RegulatorInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" Check if a regulator should be installed here.</span>
<span class="sd">        Return TRUE if</span>
<span class="sd">        - the flag reg-config-implicit-ac is present in the compuFlags</span>
<span class="sd">        - AND 'REG' is present in the 'technology flag'</span>
<span class="sd">        """</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"REG"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"reg-config-implicit-ac"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="RegulatorInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.RegulatorInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'InputPipelineStep'</span><span class="p">:</span>
        <span class="sd">"""Configure the instance.</span>
<span class="sd">        If a POF is present before, it MUST have the same configuration as reg-config-implicit-ac</span>
<span class="sd">        </span>
<span class="sd">        The flag 'reg-config-implicit-ac' should be present in the compuFlags.</span>
<span class="sd">        It should be formed as follows:</span>
<span class="sd">        "flow1,flow2,flow3:reference1;flow4,flow5:reference2"</span>
<span class="sd">        </span>
<span class="sd">        With this string, the computationnal block will represent two Interleaved regulators.</span>
<span class="sd">        The first one processes flow1,flow2,flow3 in a FIFO maner and for each of them, its shaping curve is defined as the arrival curve it has at reference 1.</span>
<span class="sd">        The second one processes flow4,flow5 in a FIFO maner and for each of them, its shaping curve is defined as the arrival curve it has at reference 2.</span>

<span class="sd">        The PFRs with the same flows are created with the configuration:</span>
<span class="sd">        "flow1:reference1;flow2:reference1;flow3:reference1;flow4:reference2;flow5:reference2"</span>
<span class="sd">        </span>
<span class="sd">        Warning: the implementation does not check the correctness of the 'reg-config-implicit-ac' string.</span>
<span class="sd">             </span>
<span class="sd">        """</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"reg-config-implicit-ac"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Computational flags must contain 'reg-config-implicit-ac'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">"POF"</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">if</span><span class="p">(</span><span class="s2">"pof-config-implicit"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Could not find 'pof-config-implicit' in the computational flags, but POF is mentionned"</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"pof-config-implicit"</span><span class="p">]</span> <span class="o">!=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"reg-config-implicit-ac"</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Sorry but xTFA supports only POF followed by REG if they both have the same exact configuration (same groups, same reference)"</span><span class="p">)</span>
            <span class="n">reg</span><span class="o">.</span><span class="n">pofIsPresentBefore</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ats_config</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"reg-config-implicit-ac"</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">group_config</span> <span class="ow">in</span> <span class="n">ats_config</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">";"</span><span class="p">):</span>
            <span class="n">group_config_items</span> <span class="o">=</span> <span class="n">group_config</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>
            <span class="n">mSetStr</span> <span class="o">=</span> <span class="n">group_config_items</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mSetStr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">","</span><span class="p">))</span>
            <span class="n">mfrozenSet</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">mSet</span><span class="p">)</span>
            <span class="n">reg</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">mfrozenSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_config_items</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">reg</span></div>

<div class="viewcode-block" id="RegulatorInputPipelineStep.areTheyInTheSameGroup"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.RegulatorInputPipelineStep.areTheyInTheSameGroup">[docs]</a>    <span class="k">def</span> <span class="nf">areTheyInTheSameGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f1</span><span class="p">:</span> <span class="n">Flow</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span> <span class="n">Flow</span><span class="p">):</span>
        <span class="sd">"""Return True if f1 and f2 are in the same group.</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">__adaptationMethodIsRequired</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isPfr</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"adam"</span><span class="p">,</span><span class="s2">"cascade"</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"A regulator adaptation method must be provided"</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"adam"</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isPfr</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"ADAM cannot be used as an adaptation method for Interleaved Regualtor"</span><span class="p">)</span>

<div class="viewcode-block" id="RegulatorInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.RegulatorInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#Nw that we have stored all the information we needed (who comes from where, under which partition), we can focus on the main pipeline</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">itsGroup</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">):</span>
                    <span class="n">itsGroup</span> <span class="o">=</span> <span class="n">group</span>
                    <span class="k">break</span>
            <span class="k">if</span><span class="p">(</span><span class="n">itsGroup</span><span class="p">):</span>
                <span class="n">iAmPfr</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">itsGroup</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">itsRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">]</span>
                <span class="c1">#get the dmax for the aggregate coming from the same reference point</span>
                <span class="k">if</span><span class="p">(</span><span class="n">itsRef</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="p">(</span><span class="n">CurveNotKnown</span><span class="p">())</span>
                <span class="n">dmax</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">]</span>
                <span class="n">dmin</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">]</span>
                
                <span class="c1">#First we check that we will not lead to unbounded latencies</span>
                
                <span class="c1">#First, the clocks</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">Clock</span><span class="o">.</span><span class="n">PERFECT</span><span class="p">):</span>
                    <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">Clock</span><span class="o">.</span><span class="n">SYNC</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__adaptationMethodIsRequired</span><span class="p">(</span><span class="n">iAmPfr</span><span class="p">)</span>
                    <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">iAmPfr</span><span class="p">):</span>
                        <span class="c1">#IR and synchronized, adaptation is required</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__adaptationMethodIsRequired</span><span class="p">(</span><span class="n">iAmPfr</span><span class="p">)</span>
                <span class="c1">#Then, the non-FIFO</span>
                <span class="k">if</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1">#system is not FIFO</span>
                    <span class="k">if</span><span class="p">((</span><span class="ow">not</span> <span class="n">iAmPfr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pofIsPresentBefore</span><span class="p">)):</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"POF is required before an IR after a non-FIFO system"</span><span class="p">)</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">iAmPfr</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pofIsPresentBefore</span><span class="p">)):</span>
                        <span class="c1">#Theorem 4.4 of the manuscript,</span>
                        <span class="c1">#penalty is D-d</span>
                        <span class="n">fs</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="n">dmax</span><span class="o">-</span><span class="n">dmin</span><span class="p">)</span>
                
            
                <span class="c1">#Now, we add the different penalties</span>
                <span class="c1">#First, the aggregate delay penalty (for IR)</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">iAmPfr</span><span class="p">):</span>
                    <span class="c1">#The first penalty that we suffer is the penalty of aggregating.</span>
                    <span class="c1">#Indeed the IR is 'for free' only for the aggregate, so everyone suffers the worst delay among the flows of the aggregate </span>
                    <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
                        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">areTheyInTheSameGroup</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span> <span class="n">ffs</span><span class="o">.</span><span class="n">flow</span><span class="p">)):</span>
                            <span class="n">dmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">ffs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">])</span>
                            <span class="n">dmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">ffs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">])</span>
                    <span class="n">myDmax</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">]</span>
                    <span class="n">penaltyDueToAggregating</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">-</span> <span class="n">myDmax</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="n">penaltyDueToAggregating</span><span class="p">)</span>
                


                
                <span class="c1"># we obtain the arrival curve at the reference point by asking the flow, providing the reference we stored</span>
                <span class="n">ac</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">])</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">Clock</span><span class="o">.</span><span class="n">PERFECT</span><span class="p">):</span>
                    <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span><span class="n">mpt</span><span class="o">.</span><span class="n">GVBR</span><span class="p">)):</span>
                        <span class="n">ac</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">get_first_lb</span><span class="p">()</span>
                    <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span> <span class="o">==</span> <span class="s2">"cascade"</span><span class="p">):</span>
                        <span class="c1">#worsen cascade</span>
                        <span class="n">nr</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">get_rate</span><span class="p">()</span><span class="o">*</span><span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span>
                        <span class="n">nb</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()</span> <span class="o">+</span> <span class="n">Clock</span><span class="o">.</span><span class="n">ETA</span> <span class="o">*</span> <span class="n">ac</span><span class="o">.</span><span class="n">get_rate</span><span class="p">()</span>
                        <span class="n">ac</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">LeakyBucket</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
                    <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span> <span class="o">==</span> <span class="s2">"adam"</span><span class="p">):</span>
                        <span class="c1">#worsen cascade</span>
                        <span class="n">ac</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">LeakyBucket</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">sourceArrivalCurve</span><span class="o">.</span><span class="n">get_rate</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">adamMargin</span><span class="p">,</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">sourceArrivalCurve</span><span class="o">.</span><span class="n">get_burst</span><span class="p">())</span>
                <span class="c1"># force the ac</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">Clock</span><span class="p">(</span><span class="s2">"H-"</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
                <span class="c1"># register the arrival curve</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">registerSpecialInternalCurve</span><span class="p">(</span><span class="s2">"ats-curve"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span>
                <span class="c1"># add the current entry to the dictionnary of delays</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">addDelayFromEntry</span><span class="p">(</span><span class="s2">"ats:</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">addRtoFromEntry</span><span class="p">(</span><span class="s2">"ats:</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
                <span class="c1"># register self as last fresh ac</span>
                <span class="n">lastref</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"last-fresh"</span><span class="p">,</span><span class="s2">"source"</span><span class="p">)</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"last-fresh"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"ats:</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
                <span class="c1">#This flow state is valid in my local time,</span>
                <span class="c1">#change for TAI</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">changeClock</span><span class="p">(</span><span class="n">Clock</span><span class="p">(</span><span class="s2">"tai"</span><span class="p">))</span>
                <span class="k">if</span><span class="p">((</span><span class="ow">not</span> <span class="n">Clock</span><span class="o">.</span><span class="n">PERFECT</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iAmPfr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Clock</span><span class="o">.</span><span class="n">SYNC</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"cascade"</span><span class="p">,</span><span class="s2">"adam"</span><span class="p">])):</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">Clock</span><span class="o">.</span><span class="n">DELTA</span><span class="p">)</span>
                <span class="k">if</span><span class="p">((</span><span class="ow">not</span> <span class="n">Clock</span><span class="o">.</span><span class="n">PERFECT</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clockAdaptationMode</span> <span class="o">==</span> <span class="s2">"adam"</span><span class="p">)):</span>
                    <span class="n">r0</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">sourceArrivalCurve</span><span class="o">.</span><span class="n">get_rate</span><span class="p">()</span>
                    <span class="n">b0</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">sourceArrivalCurve</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"adam-data"</span><span class="p">,</span> <span class="p">{</span><span class="s2">"r2"</span> <span class="p">:</span> <span class="n">r0</span> <span class="o">*</span> <span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span><span class="p">,</span> <span class="s2">"b2"</span><span class="p">:</span> <span class="n">b0</span> <span class="o">+</span> <span class="n">r0</span> <span class="o">*</span> <span class="n">Clock</span><span class="o">.</span><span class="n">ETA</span><span class="p">})</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">"r2"</span><span class="p">]</span>
                    <span class="n">b2</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">"b2"</span><span class="p">]</span>
                    <span class="n">penalty</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">.</span><span class="n">ETA</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s2">"b2"</span><span class="p">]</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">-</span> <span class="n">Clock</span><span class="o">.</span><span class="n">ETA</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">adamMargin</span> <span class="o">*</span> <span class="n">r0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span> <span class="o">*</span> <span class="n">r0</span><span class="p">))</span> <span class="o">*</span> <span class="p">((</span><span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span><span class="o">*</span><span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adamMargin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">b2</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">Clock</span><span class="o">.</span><span class="n">RHO</span> <span class="o">*</span> <span class="n">r0</span> <span class="o">*</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lastref</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lastref</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"adam-data"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"adam-data"</span><span class="p">][</span><span class="s2">"r2"</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                    <span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"adam-data"</span><span class="p">][</span><span class="s2">"b2"</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span>
                <span class="c1">#the flow is now is going to be processed alone, so IT MUST be removed from any partition it was in</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">removeFlowStateFromPartition</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                    <span class="n">newEl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
                    <span class="n">newEl</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                    <span class="c1"># no shaping</span>
                    <span class="n">newEl</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s2">"+ATS"</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Invalid partition"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateForceMergingInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionFlowStateForceMergingInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">PacketEliminationFunctionFlowStateForceMergingInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""This computational block forces the flow states of a same flow to be merged into a single flow state prior to being sent to a regulator. This block is used only when a regulator is present just after the PEF and the reason is that the regulator will recreate the flow from fresh so we don't need the flow states to be separated (the separation of flow states is useful only with partitions).</span>
<span class="sd">    """</span>
    
    <span class="n">_selectiveMerge</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_flowsToMerge</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Flow</span><span class="p">]</span>

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">"""Install if both PEF and ATS are present in the pipeline</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">PacketEliminationFunctionInputPipelineStep</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="ow">and</span> <span class="n">RegulatorInputPipelineStep</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">))</span></div>

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">compuFlags</span><span class="p">[</span><span class="s2">"packet-elimination-function"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"all"</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">instance</span>
        <span class="c1"># selective mode enabled</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_selectiveMerge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">flowMergeStr</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"packet-elimination-function"</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">","</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_flowsToMerge</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">flows</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">flowMergeStr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">instance</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aNodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">aNodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selectiveMerge</span> <span class="o">=</span> <span class="kc">False</span>       

    
    <span class="k">def</span> <span class="nf">_countFlowInFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="n">Flow</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flow</span> <span class="o">==</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">_getSetOfFlowsToMerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Flow</span><span class="p">]:</span>
        <span class="n">flowsToMerge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Count the number of flows for which we observe more than one flow state -&gt; means the flow has been duplicated</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_countFlowInFlowStates</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">flowsToMerge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="c1"># Intersect with the limiting list of flows to merge for this specific step</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selectiveMerge</span><span class="p">):</span>
            <span class="n">flowsToMerge</span> <span class="o">=</span> <span class="n">flowsToMerge</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flowsToMerge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flowsToMerge</span>

    <span class="k">def</span> <span class="nf">_getClosestKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graphOfFlow</span><span class="p">:</span> <span class="n">networkx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">sourceKeys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="s1">'source'</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sourceKeys</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="s2">":"</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="c1"># do not process ATS stuff here</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">):</span>
                <span class="c1"># This key cannot strictly be closer than the current canditate</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">):</span>
                <span class="c1"># The candidate cannot strictly be closer than the current key</span>
                <span class="c1"># so we can flip</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">continue</span>
            <span class="c1"># Here, neither 'key' nor 'candidate' can be equal to 'source' so they are valid node names in the flow graph</span>
            <span class="n">distance_candidate</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graphOfFlow</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">candidate</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
            <span class="n">distance_key</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">graphOfFlow</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">distance_key</span> <span class="o">&lt;</span> <span class="n">distance_candidate</span><span class="p">):</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">candidate</span>

    <span class="k">def</span> <span class="nf">_filterFlowStatesForAFlow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">flow</span><span class="p">:</span> <span class="n">Flow</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]:</span>
        <span class="n">flowStatesForThisFlow</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1">#get the list of flowStates</span>
        <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="o">.</span><span class="n">flow</span> <span class="o">==</span> <span class="n">flow</span><span class="p">):</span>
                <span class="n">flowStatesForThisFlow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ffs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flowStatesForThisFlow</span>
            
    <span class="k">def</span> <span class="nf">_addSufferedRtoForNodesBeforeTheSplit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowState</span><span class="p">:</span> <span class="n">FlowState</span><span class="p">,</span> <span class="n">rto</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">closestAncestor</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span><span class="p">((</span><span class="n">closestAncestor</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">'source'</span> <span class="ow">in</span> <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="c1">#Closest ancestor is source, only the source key needs to increase its rto</span>
            <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">closestAncestor</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rto</span>
            <span class="k">return</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">":"</span> <span class="ow">in</span> <span class="n">closestAncestor</span><span class="p">):</span>
            <span class="n">closestAncestor</span> <span class="o">=</span> <span class="n">closestAncestor</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1">#here I'm assuming that the tagging is complete:</span>
            <span class="c1">#meaning if a flowstate is tagged at some point in the network, than all the flowstates for the same flow are ALSO tagged</span>
            <span class="c1">#this ensures that, among the rtoFrom.keys(), we have keys that are either common to all paths and preceding the closestAncestor OR at least not present in one of the paths</span>
            <span class="c1">#hence the logic is: add the RTO to keys before the closestAncestor, but do not add it to keys that are after hte closest ancestor because we assume that at least one path is not going through this</span>
            <span class="c1">#key, so basically the packets are not "reordered" from this key because of this merge</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">'source'</span><span class="p">:</span>
                <span class="c1">#key is source, it is necessarely BEFORE the closestAncestor, increase its key</span>
                <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rto</span>
                <span class="k">continue</span>
            <span class="k">if</span><span class="p">(</span><span class="s2">":"</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">subkey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">networkx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">flowState</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">closestAncestor</span><span class="p">):</span>
                <span class="n">flowState</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rto</span>
            

    <span class="k">def</span> <span class="nf">_mergeDelayDictionnaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="n">minDelayDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">maxDelayDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">possibleKeysMin</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">possibleKeysMax</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">:</span>
            <span class="n">possibleKeysMin</span> <span class="o">=</span> <span class="n">possibleKeysMin</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">possibleKeysMax</span> <span class="o">=</span> <span class="n">possibleKeysMax</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#Then for any key, get either the max or the min of the values in the FlowStates that have this key:</span>
        <span class="k">for</span> <span class="n">keyMin</span> <span class="ow">in</span> <span class="n">possibleKeysMin</span><span class="p">:</span>
            <span class="n">minDelayDict</span><span class="p">[</span><span class="n">keyMin</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">keyMin</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">keyMin</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
        <span class="k">for</span> <span class="n">keyMax</span> <span class="ow">in</span> <span class="n">possibleKeysMax</span><span class="p">:</span>
            <span class="n">maxDelayDict</span><span class="p">[</span><span class="n">keyMax</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">keyMax</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">keyMax</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">minDelayDict</span><span class="p">,</span> <span class="n">maxDelayDict</span>
    
<div class="viewcode-block" id="PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.mergeRtoDict"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.mergeRtoDict">[docs]</a>    <span class="k">def</span> <span class="nf">mergeRtoDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="nb">float</span><span class="p">]:</span>
        <span class="n">rtoDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">possibleKeys</span><span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">:</span>
            <span class="n">possibleKeys</span> <span class="o">=</span> <span class="n">possibleKeys</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#Then for any key, get the max of the rto</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">possibleKeys</span><span class="p">:</span>
            <span class="n">rtoDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
        <span class="k">return</span> <span class="n">rtoDict</span></div>
    

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.mergeFlags"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.mergeFlags">[docs]</a>    <span class="k">def</span> <span class="nf">mergeFlags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">:</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="o">**</span><span class="n">fs</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flags</span></div>

    <span class="k">def</span> <span class="nf">_getJitterFromKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mergingFlowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">minFromKey</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
        <span class="n">maxFromKey</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">mergingFlowStates</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">maxFromKey</span> <span class="o">-</span> <span class="n">minFromKey</span><span class="p">)</span>

<div class="viewcode-block" id="PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketEliminationFunctionFlowStateForceMergingInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">flow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getSetOfFlowsToMerge</span><span class="p">(</span><span class="n">flowStates</span><span class="p">):</span>
            <span class="n">flowStatesForThisFlow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filterFlowStatesForAFlow</span><span class="p">(</span><span class="n">flowStates</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
            <span class="c1">#compute the common keys</span>
            <span class="n">fromKeys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">refClock</span> <span class="o">=</span> <span class="n">flowStatesForThisFlow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clock</span>
            <span class="k">for</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">ffs</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">refClock</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"The flow states for flow </span><span class="si">%s</span><span class="s2"> at node </span><span class="si">%s</span><span class="s2"> are not observed with the same clock. This is unexpected"</span> <span class="o">%</span> <span class="p">(</span><span class="n">flow</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">))</span>
                <span class="n">fromKeys</span> <span class="o">=</span> <span class="n">fromKeys</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ffs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="c1">#This will be the future merged flow state. We set the correct flow</span>
            <span class="n">newFlowState</span> <span class="o">=</span> <span class="n">FlowState</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
            
            <span class="c1"># clock: current node</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">refClock</span>

            <span class="c1">#We take the union of flags. Duplicates are resolved arbitrarely</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeFlags</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># We need to do a few things: first, we need to merge the dictionnaries of min [resp max] delays into a unique min [resp max] delay dictionnary</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">,</span> <span class="n">newFlowState</span><span class="o">.</span><span class="n">maxDelayFrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mergeDelayDictionnaries</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># Now we also merge the RTO dictionnaries before adding the RTO due to the merging</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">rtoFrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeRtoDict</span><span class="p">(</span><span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># Now we need to add the RTO due to the merge</span>
            <span class="c1"># To do so, we need a bound on non-FIFO jitter between the split and the merge.</span>
            <span class="c1"># The smallest bound that we can obtain is the jitter between the closest ancestor and this current node.</span>
            <span class="c1"># So first let's obtain the closest ancestor</span>
            <span class="n">closestAncestor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getClosestKey</span><span class="p">(</span><span class="n">flow</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">fromKeys</span><span class="p">))</span>
            <span class="c1"># And compute the jitter across all the flow states from this closest ancestor</span>
            <span class="n">nonFifoJitterBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getJitterFromKey</span><span class="p">(</span><span class="n">closestAncestor</span><span class="p">,</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
            <span class="c1"># And now we will add the nonFifoJitter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addSufferedRtoForNodesBeforeTheSplit</span><span class="p">(</span><span class="n">newFlowState</span><span class="p">,</span> <span class="n">nonFifoJitterBound</span><span class="p">,</span> <span class="n">closestAncestor</span><span class="p">)</span>

            <span class="c1"># NOW, WE need to select a leaky-bucket arrival curve valid JUST BEFORE the FIFO contention step</span>
            <span class="c1"># This arrival curve will ONLY be needed if the output arrival curve computation uses propagation instead of re-computing from the source</span>
            <span class="c1"># For this, we select the key for which the deconvolutated leaky-bucket has the SMALLEST BURST</span>
            <span class="n">theNewCurve</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fromKeys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">arrivalCurveAtDivergencePoint</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="c1">#curve not known here, do not use it</span>
                    <span class="k">continue</span>
                <span class="n">dmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
                <span class="n">dmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">)</span>
                <span class="n">candidateCurve</span> <span class="o">=</span> <span class="n">arrivalCurveAtDivergencePoint</span> <span class="o">/</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theNewCurve</span><span class="p">,</span> <span class="n">mpt</span><span class="o">.</span><span class="n">LeakyBucket</span><span class="p">)):</span>
                    <span class="c1">#the new curve was not assigned yet, assign it</span>
                    <span class="n">theNewCurve</span> <span class="o">=</span> <span class="n">candidateCurve</span>
                    <span class="k">continue</span>
                <span class="k">if</span><span class="p">(</span><span class="n">candidateCurve</span><span class="o">.</span><span class="n">to_leaky_bucket_with_minimum_burst</span><span class="p">()</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">theNewCurve</span><span class="o">.</span><span class="n">get_burst</span><span class="p">()):</span>
                    <span class="n">theNewCurve</span> <span class="o">=</span> <span class="n">candidateCurve</span>
            <span class="n">newFlowState</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">theNewCurve</span>
            <span class="c1"># .edge field has not been set, but it will be by the output arrival curve computation step</span>
            <span class="c1">#and of course we remove all the constituing flow states from the lis</span>
            <span class="k">for</span> <span class="n">ffffs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">removeFlowStateFromPartition</span><span class="p">(</span><span class="n">ffffs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStatesForThisFlow</span><span class="p">:</span>
                <span class="n">flowStates</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="c1">#then we can add this new flow state to the list of flow states</span>
            <span class="n">flowStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newFlowState</span><span class="p">)</span>
            <span class="c1">#and to the partitions</span>
            <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
                <span class="n">el</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">el</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newFlowState</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ppp</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ppp</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Invalid partition"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="PacketOrderingFunctionInputPipelineStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketOrderingFunctionInputPipelineStep">[docs]</a><span class="k">class</span> <span class="nc">PacketOrderingFunctionInputPipelineStep</span><span class="p">(</span><span class="n">InputPipelineStep</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    This computational block represent a set of // POF, either per flow or per-aggregate:</span>

<span class="sd">    Inheritance:</span>
<span class="sd">        InputPipelineStep:</span>

<span class="sd">    """</span>
    <span class="n">groups</span> <span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span><span class="nb">str</span><span class="p">]</span>  <span class="c1">#set of flows, reference</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonReorderingPfr</span> <span class="o">=</span> <span class="kc">False</span>
    
<div class="viewcode-block" id="PacketOrderingFunctionInputPipelineStep.checkInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketOrderingFunctionInputPipelineStep.checkInstall">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">checkInstall</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" Check if a regulator should be installed here.</span>
<span class="sd">        Return TRUE if</span>
<span class="sd">        - the flag pof-config-implicit is present in the compuFlags</span>
<span class="sd">        - AND 'POF' is present in the 'technology flag'</span>
<span class="sd">        """</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"POF"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"\+|\:|\/"</span><span class="p">,</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"technology"</span><span class="p">,</span><span class="s2">""</span><span class="p">))):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"pof-config-implicit"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PacketOrderingFunctionInputPipelineStep.getConfiguredInstanceForNode"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketOrderingFunctionInputPipelineStep.getConfiguredInstanceForNode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getConfiguredInstanceForNode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'InputPipelineStep'</span><span class="p">:</span>
        <span class="sd">"""Configure the instance.</span>
<span class="sd">        </span>
<span class="sd">        The flag 'pof-config-implicit' should be present in the compuFlags.</span>
<span class="sd">        It should be formed as follows:</span>
<span class="sd">        "flow1,flow2,flow3:reference1;flow4,flow5:reference2"</span>
<span class="sd">        </span>
<span class="sd">        With this string, the computationnal block will represent two POFs.</span>
<span class="sd">        The first one processes flow1,flow2,flow3 and reorders them as an aggregate, in the order they had at reference 1.</span>

<span class="sd">             </span>
<span class="sd">        """</span>
        <span class="n">pofs</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="s2">"pof-config-implicit"</span> <span class="ow">in</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">pof_config</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="p">[</span><span class="s2">"pof-config-implicit"</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">group_config</span> <span class="ow">in</span> <span class="n">pof_config</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">";"</span><span class="p">):</span>
                <span class="n">group_config_items</span> <span class="o">=</span> <span class="n">group_config</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>
                <span class="n">mSetStr</span> <span class="o">=</span> <span class="n">group_config_items</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">mSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mSetStr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">","</span><span class="p">))</span>
                <span class="n">mfrozenSet</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">mSet</span><span class="p">)</span>
                <span class="n">pofs</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">mfrozenSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_config_items</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pofs</span></div>

<div class="viewcode-block" id="PacketOrderingFunctionInputPipelineStep.areTheyInTheSameGroup"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketOrderingFunctionInputPipelineStep.areTheyInTheSameGroup">[docs]</a>    <span class="k">def</span> <span class="nf">areTheyInTheSameGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f1</span><span class="p">:</span> <span class="n">Flow</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span> <span class="n">Flow</span><span class="p">):</span>
        <span class="sd">"""Return True if f1 and f2 are in the same group.</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="PacketOrderingFunctionInputPipelineStep.executeStep"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.PacketOrderingFunctionInputPipelineStep.executeStep">[docs]</a>    <span class="k">def</span> <span class="nf">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">],</span> <span class="n">partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">myDataPerGroup</span> <span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span><span class="n">List</span><span class="p">]</span>

        <span class="n">myFlowStates</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span><span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]]</span>

        <span class="n">myDataPerGroup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">myFlowStates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">mset</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">mpt</span><span class="o">.</span><span class="n">NoCurve</span><span class="p">()]</span>
            <span class="c1">#dmin for aggregate since ref</span>
            <span class="c1">#dmax for aggregate since ref</span>
            <span class="c1">#arrival curve of aggregate at ref</span>
            <span class="n">myFlowStates</span><span class="p">[</span><span class="n">mset</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="n">itsGroup</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">):</span>
                    <span class="n">itsGroup</span> <span class="o">=</span> <span class="n">group</span>
                    <span class="k">break</span>
            <span class="k">if</span><span class="p">(</span><span class="n">itsGroup</span><span class="p">):</span>
                <span class="n">itsRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">]</span>
                <span class="n">myFlowStates</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>            
                <span class="n">itsMax</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">]</span>
                <span class="n">itsMin</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">minDelayFrom</span><span class="p">[</span><span class="n">itsRef</span><span class="p">]</span>
                <span class="k">if</span><span class="p">(</span><span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">itsMax</span>
                <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">itsMin</span><span class="p">)</span>
                <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">itsMax</span><span class="p">)</span>
                <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">itsGroup</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="n">itsRef</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">myFlowStates</span><span class="p">[</span><span class="n">group</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="c1">#First, compute the new individual arrival curve for each, Thm 5 of Ehsan and JYLB paper on reordering metrics</span>
            <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">myFlowStates</span><span class="p">[</span><span class="n">group</span><span class="p">]:</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">arrivalCurve</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">getArrivalCurveAfterOutputPort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">])</span> <span class="o">/</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1">#arrival curve at the reference, worsened by the jitter of the AGGREGATE:</span>
                <span class="c1"># myDataPerGroup[group][1] is max delay from reference for the aggregate,</span>
                <span class="c1"># myDataPerGroup[group][0] is min delay from reference for the aggregate,</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">addSufferedDelay</span><span class="p">(</span><span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fs</span><span class="o">.</span><span class="n">maxDelayFrom</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]])</span>
                <span class="c1">#The POF is for free FOR THE AGGREGATE, but not for the flow individually, so the difference between the aggregate max and the individual max is an additionnal suffered delay</span>
                <span class="n">fs</span><span class="o">.</span><span class="n">rtoFrom</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="c1">#the flow is reordered</span>
            <span class="c1">#Then, for each incoming partition</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
                <span class="c1"># We need to remove all flow states from the partition because the POF worsens the arrival curves</span>
                <span class="n">newPartEl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">createPartitionElement</span><span class="p">()</span>
                <span class="c1">#arrival curve of the group processed by the flow is its arrival curve at the ref, ie myDataPerGroup[group][2], worsened by the jitter of the aggregate since the ref</span>
                <span class="n">newPartEl</span><span class="o">.</span><span class="n">aggregateShaping</span> <span class="o">=</span> <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">mpt</span><span class="o">.</span><span class="n">BoundedDelayServiceCurve</span><span class="p">(</span><span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">myDataPerGroup</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">myFlowStates</span><span class="p">[</span><span class="n">group</span><span class="p">]:</span>
                    <span class="n">newPartEl</span><span class="o">.</span><span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                    <span class="c1">#remove from partition</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">removeFlowStateFromPartition</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s2">"+POF"</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">isPartition</span><span class="p">(</span><span class="n">flowStates</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Invalid partition"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkAllPartitions</span><span class="p">(</span><span class="n">partitions</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">)</span></div></div>
<div class="viewcode-block" id="InputPipeline"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline">[docs]</a><span class="k">class</span> <span class="nc">InputPipeline</span><span class="p">:</span>
    <span class="sd">""" This object represents an input pipeline. The role of the input pipeline is to compute the arrival curve of the aggregate arriving at the queuing subsystem. A pipeline is made of successive pipeline steps.Each pipeline step may:</span>
<span class="sd">        - modify the individual flow states, in particular their arrival curve or add new flow states, in particular to represent a local generation of flows.</span>
<span class="sd">        - modify the already existing partitions by modifying, removing or adding partition elements to the already existing partitions or by modifying the shaping curve associated with a partition element. It may also create a new partition.</span>
<span class="sd">    Partitions represent way to group several flow states into 'partition elements' and to shape these groups usiong shaping curves. To learn more, see FlowsPartition, FlowsPartitionElements and InputPipelineStep.</span>

<span class="sd">    AutoInstall feature: input pipelines can be auto configured using the autoInstall method. Then each class in the availableModules list attribute will be asked (using a class method) if an instance of this module should be installed on the pipeline for this node, and if so, a configured instance will be appended to the current pipeline.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        - availableModules (class-level): a list of InputPipeline class names, available for auto install. Step will be appended in the same order (if applicatble), so the order in this list is important.</span>
<span class="sd">        - pipeline (List[InputPipelineStep]): the pipeline (list of InputPipelineStep instances) for this instance.</span>
<span class="sd">        - flags: a dictionnary to store flags on the state of the pipeline </span>
<span class="sd">    """</span>
    
    <span class="c1">#List of available computational blocks.</span>
    <span class="c1">#The order of these modules mater for autoconfiguration because each of these class, in thi order, will be asked whether it should be instanciated based on the autoconfiguration flags (flags in compuFlag + content of the 'technology' string)</span>
    <span class="n">availableModules</span> <span class="o">=</span> <span class="p">[</span><span class="n">InitialPerInputPortAggregatorInputPipelineStep</span><span class="p">,</span> <span class="n">InputPortShapingInputPipelineStep</span><span class="p">,</span> <span class="n">PacketizationInputPipelineStep</span><span class="p">,</span> <span class="n">CutThroughInputPipelineStep</span><span class="p">,</span> <span class="n">PacketEliminationFunctionInputPipelineStep</span><span class="p">,</span> <span class="n">PacketEliminationFunctionFlowStateForceMergingInputPipelineStep</span><span class="p">,</span> <span class="n">PacketOrderingFunctionInputPipelineStep</span><span class="p">,</span> <span class="n">RegulatorInputPipelineStep</span><span class="p">,</span> <span class="n">LocalSourceApplicationsInputPipelineStep</span><span class="p">]</span>

    <span class="n">pipeline</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">InputPipelineStep</span><span class="p">]</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">dict</span>
    
    <span class="n">_nodeName</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">_flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]</span>
    <span class="n">_partitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowsPartition</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Creates a pipeline with an empty pipeline and the flag "pipeline_finished" at False</span>

<span class="sd">        Args:</span>
<span class="sd">            nodeName (str): the name of the node for this pipeline</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"pipeline_finished"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partitions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span> <span class="o">=</span> <span class="n">nodeName</span>


<div class="viewcode-block" id="InputPipeline.autoInstall"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.autoInstall">[docs]</a>    <span class="k">def</span> <span class="nf">autoInstall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compuFlags</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">net</span><span class="p">:</span> <span class="s1">'networks.Network'</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Performs the auto install procedure for this pipeline.</span>
<span class="sd">                                                                                                                </span>
<span class="sd">        Args:</span>
<span class="sd">            compuFlags (Mapping): a dictionnary that gives the computationnal flags for this node</span>
<span class="sd">            net (networks.Network): a reference to the network</span>
<span class="sd">            nodeName (str): the name of the node</span>
<span class="sd">        """</span>
        <span class="c1"># TODO: check if next line is still necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"plot-delay-computation"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-delay-computations"</span><span class="p">,</span><span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"true"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"plot-partition-result"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-partition-result"</span><span class="p">,</span><span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"true"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"start_from_infinite"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"start_from_infinite"</span><span class="p">,</span><span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"true"</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"plot-partition-result"</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"plot-partition-result-flags"</span><span class="p">]</span> <span class="o">=</span> <span class="n">compuFlags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-partition-result-flags"</span><span class="p">,{})</span>
        <span class="c1">#for each available module, ask and configure</span>
        <span class="k">for</span> <span class="n">avType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">availableModules</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">avType</span><span class="o">.</span><span class="n">checkInstall</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">appendPipelineElement</span><span class="p">(</span><span class="n">avType</span><span class="o">.</span><span class="n">getConfiguredInstanceForNode</span><span class="p">(</span><span class="n">compuFlags</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">nodeName</span><span class="p">))</span></div>

<div class="viewcode-block" id="InputPipeline.appendPipelineElement"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.appendPipelineElement">[docs]</a>    <span class="k">def</span> <span class="nf">appendPipelineElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pipelineElement</span><span class="p">:</span> <span class="n">InputPipelineStep</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Appends an InputPipelineStep to the pipeline</span>

<span class="sd">        Args:</span>
<span class="sd">            pipelineElement (InputPipelineStep): the step to add</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pipelineElement</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputPipeline.setInputFlowStates"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.setInputFlowStates">[docs]</a>    <span class="k">def</span> <span class="nf">setInputFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flowStates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">""" Sets the flow states at the input of the input pipeline (a copy will be performed using the copy() method of FlowState)</span>

<span class="sd">        Args:</span>
<span class="sd">            flowStates (List[FlowState]): the flow states entering the input pipeline</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">flowStates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="InputPipeline.getOutputFlowStates"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.getOutputFlowStates">[docs]</a>    <span class="k">def</span> <span class="nf">getOutputFlowStates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FlowState</span><span class="p">]:</span>
        <span class="sd">"""Returns the flow states as they are at the output of the input pipeline (may have been modified by packetizers, regulators etc within the pipeline)</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: if the pipeline has not been executed beforehand</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[FlowState]: the lsit of the flow states at the output of the input pipeline</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Pipeline must be computed before calling getFinalArrivalCurve"</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="InputPipeline.processPipeline"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.processPipeline">[docs]</a>    <span class="k">def</span> <span class="nf">processPipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""Processes the pipeline (each step, in their order in the list of pipeline element)</span>
<span class="sd">        """</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"'pipeline_finished' must be 'False' to process the pipeline. Cannot do it twice"</span><span class="p">)</span>
        <span class="c1">#Call each step of the pipeline</span>
        <span class="k">for</span> <span class="n">inputPipelineStep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="p">:</span>
            <span class="n">inputPipelineStep</span><span class="o">.</span><span class="n">executeStep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partitions</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">Clock</span><span class="o">.</span><span class="n">PERFECT</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">is_tai</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"At the output of the following input pipeline step, not all flow states are observed in TAI, which is unexpected: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">inputPipelineStep</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"pipeline_finished"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="InputPipeline.isFinished"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.isFinished">[docs]</a>    <span class="k">def</span> <span class="nf">isFinished</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">""" Checks if pipeline has been executed</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if pipeline is finished, False otherwise</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputPipeline.getFinalArrivalCurve"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.getFinalArrivalCurve">[docs]</a>    <span class="k">def</span> <span class="nf">getFinalArrivalCurve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mpt</span><span class="o">.</span><span class="n">Curve</span><span class="p">:</span>
        <span class="sd">""" Returns the arrival curve for the aggregate at the end of the pipeline</span>

<span class="sd">        Returns:</span>
<span class="sd">            minPlusToolbox.Curve: the aggregate arrival curve resulting from the pipeline</span>
<span class="sd">        """</span>
        <span class="c1">#if pipeline not processed, cannot get final arrival curve</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"pipeline_finished"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">"Pipeline must be computed before calling getFinalArrivalCurve"</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"No flow states in the pipeline, return NoCurve()"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mpt</span><span class="o">.</span><span class="n">NoCurve</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"start_from_infinite"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">InfiniteCurve</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="n">mpt</span><span class="o">.</span><span class="n">NoCurve</span><span class="p">()</span>
            <span class="c1">#First, add all the individual flows to get a first convolution element</span>
            <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">:</span>
                <span class="n">curve</span> <span class="o">=</span> <span class="n">curve</span> <span class="o">+</span> <span class="n">fs</span><span class="o">.</span><span class="n">getCopyInternalArrivalCurve</span><span class="p">()</span>
            <span class="c1">#Now, for every parition, sum the resulting arrival curves for every element and convoluate every resulting curve</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-partition-result"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
            <span class="n">toPlot</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partitions</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-partition-result"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
                <span class="n">thisCurve</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">getResultingArrivalCurve</span><span class="p">()</span>
                <span class="n">thisCurve</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">toPlot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisCurve</span><span class="p">)</span>
            <span class="n">thisthisCurve</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">getResultingArrivalCurve</span><span class="p">()</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="n">curve</span> <span class="o">*</span> <span class="n">thisthisCurve</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2">:AggregatedAC:</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span><span class="p">,</span> <span class="n">curve</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()))</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-partition-result"</span><span class="p">,</span><span class="kc">False</span><span class="p">)):</span>
            <span class="n">genCurve</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span>
            <span class="n">genCurve</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">"Final"</span><span class="p">)</span>
            <span class="n">mpt</span><span class="o">.</span><span class="n">plot_arrival_curves</span><span class="p">(</span><span class="o">*</span><span class="n">toPlot</span><span class="p">,</span> <span class="n">genCurve</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span> <span class="o">+</span> <span class="s2">" (ACs from partitions)"</span><span class="p">,</span> <span class="n">without_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"plot-partition-result-flags"</span><span class="p">,{}))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%s</span><span class="s2">:PipelineContent:</span><span class="se">\n</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodeName</span>
            <span class="k">for</span> <span class="n">ips</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">"- "</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">ips</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1">#clear all internal penalties</span>
        <span class="k">for</span> <span class="n">fss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span><span class="p">:</span>
            <span class="n">fss</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"internal-penalty"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curve</span></div>

<div class="viewcode-block" id="InputPipeline.clearPipelineComputations"><a class="viewcode-back" href="../../xtfa.inputPipelines.html#xtfa.inputPipelines.InputPipeline.clearPipelineComputations">[docs]</a>    <span class="k">def</span> <span class="nf">clearPipelineComputations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">"pipeline_finished"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flowStates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_partitions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pipeElement</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="p">:</span>
            <span class="n">pipeElement</span><span class="o">.</span><span class="n">clearComputations</span><span class="p">()</span></div></div>


<span class="kn">from</span> <span class="nn">xtfa</span> <span class="kn">import</span> <span class="n">networks</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Ludovic Thomas
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>